[
  
  {
    "title"    : "MobX i Flutter - automatyczny stan",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-mobx/",
    "date"     : "July 15, 2020",
    "excerpt"  : "Flutter posiada dziesiątki rozwiązań przeznaczonych do zarządzania stanem aplikacji. Bardziej, lub mniej popularne, przekombinowane, proste w użyciu. Generalnie jest pełen wachlarz możliwości i każdy bez problemu znajdzie coś dla siebie i swojego ...",
  "content"  : "Flutter posiada dziesiątki rozwiązań przeznaczonych do zarządzania stanem aplikacji. Bardziej, lub mniej popularne, przekombinowane, proste w użyciu. Generalnie jest pełen wachlarz możliwości i każdy bez problemu znajdzie coś dla siebie i swojego projektu.\n\nCo jednak zrobić, gdy nie masz czasu, ani chęci w testowaniu i porównywaniu mnogości opcji? Postaw na sprawdzony wariant w postaci MobX, który w ekosystemie JavaScript już dawno udowodnił, że ma solidne fundamenty, a praca z nim to czysta przyjemność. Warto na niego postawić również w przypadku aplikacji Flutterowych!\n\nMobX\n\nMobX to biblioteka do zarządzania stanem, w której wiele rzeczy dzieje się automatycznie. Sprawia to, że jako programista nie musisz się nimi przejmować. Wszystko za sprawą TFRP (Transparent Functional Reactive Programming) wokół którego wszystko zostało zaprojektowane i zbudowane. Z jednej strony magiczne rozwiązania to zło, bo przecież musisz wiedzieć jak wszystko dokładnie działa, a z drugiej … Czy nie chcesz przestać się martwić o każdy jeden aspekt oprogramowania? W Darcie nie zajmujesz się alokacją pamięci, ani też jej uwalnianiem, i zakładam, że nie chciałbyś robić tego ręcznie. Garbage Collector sam się wszystkim zajmuje. Czasem lepiej zdać się na gotowe i sprawdzone rozwiązanie, a samemu skupić się na rzeczach, które trudniej zautomatyzować narzędziami. Jak chociażby implementacja logiki biznesowej, czy zapierający dech w piersiach UI.\n\nTo co finalnie otrzymujesz korzystając z MobX to posiadanie zawsze aktualnego stanu, który wyświetlany jest użytkownikowi. A wszystko to przy niskim nakładzie pracy i prostocie kodu, którą potrafiłbym wytłumaczyć nawet mojej mamie. Oczywiście pod warunkiem że by chciała … a w to szczerze wątpie.\n\nFundamenty koncepcyjne\n\nFundamenty MobX składają się z zaledwie trzech podstawowych konceptów. Są to odpowiednio:\n\n\n  Observable, przechowujący stan aplikacji w formie obserwowalnej\n  Akcja (Action) do manipulowania (zmieniania) stanu\n  Reakcja (Reaction), jako obserwator stanu uruchamiany po jego każdorazowej zmianie\n\n\nPrzyjrzymy się każdej ze składowych z bliska już za moment, podczas budowania prostej aplikacji, ale poniższy diagram w prosty sposób prezentuje jakie są zależności między tymi elementami. Uruchomienie akcji (Actions) prowadzi do zmiany stanu (Observables), który powiadamia o tym fakcie powiązane reakcje (Reactions).\n\n\n\nPrzygotowanie projektu\n\nW celu wykorzystania pełnego potencjału drzemiącego w MobX będziemy potrzebowali kilku zależności. Nie jest to co prawda wymóg, ale im większy projekt budujesz tym bardziej docenisz dostarczoną automatyzację.\n\nPodstawowa paczka to mobx. Dostarcza pełne wsparcie biblioteczne do zarządzania stanem i nie jest ograniczona do działania wyłącznie we Flutterze. Możesz jej równie dobrze używać w aplikacjach konsolowych pisanych w czystym Darcie. Jej uzupełnieniem jest flutter_mobx, dzięki któremu dostajemy wymieniony wyżej element reakcji w postaci widgeta Observer.\n\nDwie kolejne biblioteki są umieszczone w sekcji dev_dependencies, bo używamy ich tylko w fazie developmentu. Nie są one częścią zbudowanej już aplikacji, a stanowią ”jedynie” wsparcie programisty w postaci narzędzia. W projekcie wykorzystamy je do automatycznego generowania klas, aby zademonstrować maksymalne ograniczenie powtarzalnego kodu (boilerplate code).\n\ndependencies:\n  # ...\n  mobx:\n  flutter_mobx:\n\ndev_dependencies:\n  # ...\n  build_runner:\n  mobx_codegen:\n\n\n\n  Pamiętaj o zainstalowaniu nowo dodanych zależności przez flutter pub get.\n\n\nUI aplikacji\n\nAplikacja pokazowa ma dwa zasadnicze ekrany i jej celem jest jedynie pokazanie jak wspołgrać z MobXem. Nie doszukuj się w niej przełomowych funkcjonalności, a tym bardziej ładnego UI - to dobry motyw na całkowicie osobny wpis.\n\n\n  Pierwszy ekran (startowy) informuje użytkownika że musi się zalogować poprzez stuknięcie w przycisk.\n  Drugi ekran wyświetla aktualnie zalogowanego użytkownika. Nazwa, data urodzenia i lista umiejętności, którą można rozszerzać.\n\n\nDodatkowo w górnym pasku zawsze prezentowana jest ilość użytkowników, którzy wylogowali się podczas trwania sesji użytkowej.\n\n\n    \n    \n        \n    \n    \n    \n        \n    \n    \n\n\nKod statycznej aplikacji, czysty UI:\n\nimport &#39;package:flutter/material.dart&#39;;\n\nvoid main() =&amp;gt; runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final isAuthenticated = false;\n\n    return MaterialApp(\n      theme: ThemeData(\n        textTheme: TextTheme(\n          bodyText2: TextStyle(\n            fontSize: 20,\n          ),\n        ),\n      ),\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text(&quot;Previous users: 0&quot;),\n        ),\n        body: Center(\n          child: isAuthenticated ? Authenticated() : Unauthenticated(),\n        ),\n      ),\n    );\n  }\n}\n\nclass Unauthenticated extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(&quot;Detected unauthenticated user!&quot;),\n        RaisedButton(\n          onPressed: login,\n          child: Text(&quot;Log in&quot;),\n        ),\n      ],\n    );\n  }\n\n  void login() {}\n}\n\nclass Authenticated extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final name = &quot;Kamil&quot;;\n    final birthDate = DateTime(1988, 6, 1);\n    final skills = [&quot;Flutter&quot;, &quot;Dart&quot;];\n\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.center,\n      children: [\n        Text(&quot;Name: $name&quot;),\n        Text(&quot;Birth date: $birthDate&quot;),\n        Text(&quot;Skills: $skills&quot;),\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            RaisedButton(\n              onPressed: addSkill,\n              child: Text(&quot;New skill&quot;),\n            ),\n            RaisedButton(\n              onPressed: logout,\n              child: Text(&quot;Log out&quot;),\n            ),\n          ],\n        )\n      ],\n    );\n  }\n\n  void addSkill() {}\n\n  void logout() {}\n}\n\n\nAplikacja się kompiluje i po uruchomieniu prezentowany jest ekran startowy. Przycisk logowania jest na chwilę obecną wydmuszką, więc jedyną możliwością wyświetlenia ekranu zalogowanego użytkownika jest ręczna zmiana flagi w kodzie:\n\nfinal isAuthenticated = true;\n\n\nPrzechodzimy zatem do najważniejszej kwestii, czyli do wprowadzenia stanu aplikacji. Umożliwienie logowania, wylogowania, oddelegowania zarządzania danymi poza drzewo widgetów.\n\nModel danych\n\nNiezależnie od tego z jaką technologią zarządzania stanem pracujesz, zawsze modeluj swoje dane. Zawsze. Nie trzymaj luźno lewitujących zmiennych, które jasno opisują pewien byt w systemie. W naszym przypadku mamy koncept użytkownika, którego opisują takie cechy jak jego nazwa, data urodzenia, czy lista posiadanych umiejętności. Zaprojektujmy więc dla niego czysty model, inaczej mówiąc worek na dane.\n\nTuż obok main.dart dodamy nowy plik data.dart, którym zdefiniujemy czym jest użytkownik naszego systemu. Klasa ta może być później śmiało wykorzystywana w innym dowolnym miejscu aplikacji. A najpewniej przeżyje nawet takie turbulencje, jak konieczność całkowitego wymienienia innej warstwy aplikacji.\n\nclass User {\n  final String name;\n  final DateTime birthDate;\n  final List&amp;lt;String&amp;gt; skills;\n\n  User(this.name, this.birthDate, this.skills);\n\n  User copyWith({List&amp;lt;String&amp;gt; skills}) {\n    return User(\n      name,\n      birthDate,\n      skills,\n    );\n  }\n}\n\n\nObservables\n\nObservable stanowi reaktywny stan aplikacji. Przez reaktywny mam na myśli taki, który umożliwia reagowanie na to co się z nim dzieje. W szczególności na zachodzące wewnątrz zmiany. Każdy dowolny obiekt możliwy do zdefiniowania w samym Darcie może stać się w łatwy sposób obserwowalny. Nie ważne, czy mamy do czynienia z wartościami prymitywnymi jak String, czy bool, czy złożonymi obiektami własnych klas. Wszystko w MobX może stać się obserwowalne.\n\nDodajmy plik store.dart w którym będziemy przechowywać zarówno stan w postaci Observable, jak również akcje do manipulowania danymi. Omówienie kodu tuż poniżej.\n\nimport &#39;package:flutter_demo_mobx/data.dart&#39;;\nimport &#39;package:mobx/mobx.dart&#39;;\n\npart &#39;store.g.dart&#39;;\n\nclass UserStore = UserStoreBase with _$UserStore;\n\nabstract class UserStoreBase with Store {\n  @observable\n  User me;\n\n  @observable\n  ObservableList&amp;lt;User&amp;gt; previousUsers = ObservableList();\n\n  @computed\n  bool get isAuthenticated =&amp;gt; me != null;\n}\n\n\nTrochę się tu dzieje, prawda? Na szczególną uwagę zasługuje część kodu wymagana przez mobx_codegen do wygenerowania za nas całego boilerplate. Nie jest to coś czym zaprzątasz sobie głowę w codziennej pracy, ale warto wiedzieć jak to ugryźć.\n\npart &#39;store.g.dart&#39;;\n\nclass UserStore = UserStoreBase with _$UserStore;\n\n\nTe dwie linie to jedyne powtarzalne kawałki kodu, które przewijają się gdy definiujemy nową domenę stanu. Nie jest to specjalnie wygórowana cena za późniejszy minimalizm, zwłaszcza, że im bardziej złożona aplikacja tym większe czerpiemy benefity z samego MobX. Nazwa store.g.dart to nic innego jak nazwa pliku głównego z zamienionym rozszerzeniem z .dart na .g.dart. Gdy przejdziemy do generowania kodu będziesz mógł do niego nawet zajrzeć.\n\nDalej mamy zdefiniowane dwie składowe oznaczone adnotacją (annotation) @observable. W obiekcie me chcemy przechowywać aktualnie zalogowanego użytkownika, a w previousUsers listę wszystkich tych, którzy się wylogowali. Warto zwrócić uwagę na wykorzystanie ObservableList zamiast wbudowanego w Darta List. Oba udostępniają taki sam interfejs, a skorzystanie z ObservableList zagwarantuje nam to, że jeśli zmienią się elementy wewnątrz listy (np. zostanie dodany nowy wpis) to zostaniemy o tym powiadomieni jak przy każdej innej zmianie.\n\nOstatni użyty element stanowi isAuthenticated. Jest to również Observable, ale w postaci wnioskowej na podstawie innych zdefiniowanych obiektów Observable. Oznacza to, że nie trzymamy tam zupełnie nowych danych, a jedynie wartość która jest wyliczana na podstawie innych danych w aplikacji. To co daje nam @computed to pełna gwarancja tego, że zawsze będzie posiadał aktualną wartość, która zmieni się natychmiast gdy jakikolwiek nasłuchiwany obiekt zostanie zmieniony. MobX sam zajmie się ustaleniem jakie Observable zostały użyte do wyliczeń i będzie pilnował spójności danych w najwydajniejszy możliwy sposób.\n\nTo tyle jeśli chodzi o zdefiniowanie stanu. Zawsze gdy chcesz go rozbudować wystarczy dodać nowy obiekt udekorowany jedną z dostępnych adnotacji: @observable, lub @computed.\n\nActions\n\nDo zarządzania danymi przechowywanymi w Observable wykorzystywane są akcje (actions). Jeśli chcesz dokonać jakiejkolwiek zmiany w stanie aplikacji, definiujesz po prostu funkcję, która zrobi to co powinna. Bez zbędnych komplikacji w postaci obsługi i mapowania zdarzeń, czy ręcznego powiadamiania reszty aplikacji, że coś się właśnie wydarzało.\n\nJak już wspomniałem akcja to najzwyklejsza funkcja i jedyne co ją wyróżnia w kodzie to adnotacja @action. Pełni ona dwie role. Pierwsza czysto semantyczna, wskazuje które funkcje manipulują stanem. Druga, czysto techniczna, gwarantuje transakcyjność. Dzięki niej, wszystkie Observable zmieniające swoje wartości w trakcie trwania akcji, powiadomią o tym fakcie dopiero po zakończeniu wykonania funkcji. Jeśli zmieniasz w ramach pojedynczej akcji kilka obiektów to reakcja po stronie aplikacji będzie tylko na samym końcu. Dla nas oznacza to w ostatecznym rozrachunku mniejszą ilość rebuildów UI.\n\nabstract class UserStoreBase with Store {\n  // ...\n\n  @action\n  void login() {\n    me = User(\n      &quot;Kamil #${previousUsers.length}&quot;,\n      DateTime(1988, 6, 1),\n      [&quot;Dart&quot;, &quot;Flutter&quot;],\n    );\n  }\n\n  @action\n  void logout() {\n    previousUsers.add(me);\n    me = null;\n  }\n\n  @action\n  void addSkill() {\n    me = me.copyWith(skills: [...me.skills, &quot;new skill&quot;]);\n  }\n}\n\n\nDodaliśmy trzy akcje: login, logout i addSkill. Każda dokonuje pewnych zmian na Observable, a najciekawsza z nich jest ta ostatnia. Chcąc dodać nową umiejętność dla obecnie zalogowanego użytkownika, nie dodajemy jej bezpośrednio do listy posiadanych już umiejętności. Taki zapis nie zadziała.\n\n@action\nvoid addSkill() {\n  me.skills.add(&quot;new skill&quot;);\n}\n\n\nLista skills w klasie User nie jest Observable, co skutkuje tym, że MobX nie dowie się o tej zmianie i nie wyemituje sygnału do zareagowania na nią. Można ten problem rozwiązać na dwa sposoby:\n\n\n  Zaprojektowanie klasy User w taki sposób, żeby jej część była obserwowalna. Kłóci się to jednak z koncepcją worka danych, którego jedynym zadaniem jest opisanie użytkownika i wystawienie czystego interfejsu. Możesz się z tym kłócić - śmiało. Architektura aplikacji to kwestia elastyczna, a to tylko mój punkt widzenia.\n  Korzystanie z Immutable objects, czyli obiektów których stan nie może zostać zmieniony. Jedyną możliwością na dokonanie zmiany jest utworzenie bliźniaczego obiektu i przypisanie jego instancji w miejsce starej referencji. We Flutterze konwencją jest, że obiekty takie implementują funkcję copyWith do której podajemy opcjonalne pola do aktualizacji, a reszta zostanie skopiowana z oryginalnego obiektu. Jeśli nie chcesz implementować podobnej funkcji w każdej jednej klasie która tego wymaga, zainteresuj się proszę biblioteką freezed. Działa w oparciu o automatyczne generowanie kodu, zupełnie jak mobx_codegen.\n\n\nW przykładzie jak widać wybrałem rozwiązanie #2, Immutable objects to coś co szkaluję szanuję.\n\nGenerowanie kodu\n\nZanim przejdziemy do ostatniego elementu, czyli reakcji, wygenerujmy wspomniany już wcześniej plik store.g.dart. Jest to proces w pełni automatyczny, a sam nie musisz nawet do niego zaglądać. To trochę tak jakbyś chciał podejrzeć zdjęcie w terminalu, albo kod wynikowy programu (.exe, .dmg). W celu jednorazowego wygenerowania pliku uruchom:\n\nflutter pub run build_runner build --delete-conflicting-outputs\n\n\nIstnieje również tryb obserwowania, który przegeneruje niezbędne pliki przy każdorazowej ich zmianie. Możesz go przykładowo włączyć, gdy rozpoczynasz pracę i zapomnieć na cały dzień.\n\nflutter pub run build_runner watch --delete-conflicting-outputs\n\n\nJeśli postanowisz sprawdzić jak wygląda nowo wygenerowany plik - śmiało. Jest czytelny, a najważniejsza informacja jest zawarta już w pierwszej linii:\n\n// GENERATED CODE - DO NOT MODIFY BY HAND\n\n\nNigdy, przenigdy nie wprowadzaj zmian w plikach auto-generowanych. Zdarzyło mi się popełnić kilka razy ten błąd w życiu (nie w Darcie) gdzie zamiast na pliku wejściowym operowałem na tym wygenerowanym. Wystarczy wtedy jedno nieumyślne poproszenie o przegenerowanie plików i cała praca zostaje nadpisana przez automat.\n\nPytanie co robić z plikami .g.dart - trzymać je w repozytorium, czy może dodać do ignorowanych? Osobiście nie wysyłam ich do systemu kontroli wersji, bo nie mają same w sobie żadnej wartości. Wystarczy uruchomić skrypt i zostaną automatycznie wygenerowane na nowo na podstawie plików źródłowych. Wybór jednak zostawiam tobie, żadne podejście nie jest grzechem śmiertelnym i zależy od osobistych preferencji.\n\nReactions\n\nCzas na element, który będzie potrafił zareagować na zmiany w Observable. Reakcja (reaction) to inaczej Observer, funkcja zarejestrowana i uruchamiana zawsze gdy powiązany z nią Observable zmieni swój stan. Nie będziemy pisać reakcji niskopoziomowych, skupimy się wyłącznie na tej, która interesuje nas najbardziej z punktu widzenia aplikacji mobilnej. Zmiana stanu to zmiana UI.\n\nTutaj wkracza moja ulubiona część, czyli biblioteka flutter_mobx. Jedyne co dostarcza to pojedynczy widget Observer, który jest swoistą reakcją. Przebuduje się on automatycznie za każdym razem, gdy będzie taka potrzeba.\n\nWróćmy zatem do naszego UI (main.dart) i tchnijmy w niego nieco życia. Na początku warto by było zainicjalizować stan.\n\nvoid main() =&amp;gt; runApp(MyApp());\n\nfinal store = UserStore();\n\n\nZainicjalizowałem właśnie zmienną globalną. GLOBALNĄ. W prawdziwej aplikacji zdecydowanie bym tego unikał, ale proste rzeczy są proste, stąd taki wybór do demonstracji. Jeśli chcesz zbudować większą i przede wszystkim testowalną aplikację, polecam użycie get_it, lub provider, aby dostarczać stan aplikacji w dół drzewa. We własnych projektach korzystam z get_it, bo robi w tym wypadku to samo co provider, ale za to mniejszą ilością kodu i bez potrzeby przekazywania kontekstu (context).\n\nCo dalej? Wszędzie tam, gdzie chcesz mieć dostęp do zawsze aktualnego stanu użyj widgeta Observer. Owijamy, więc Scaffold i dostarczamy do niego stan.\n\nPrzed:\nScaffold(\n  appBar: AppBar(\n    title: Text(&quot;Previous users: 0&quot;),\n  ),\n  body: Center(\n    child: isAuthenticated ?\n      Authenticated() :\n      Unauthenticated(),\n  ),\n)\n\n\nPo:\nObserver(\n  builder: (_) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(&quot;Previous users: ${store.previousUsers.length}&quot;),\n      ),\n      body: Center(\n        child: store.isAuthenticated ? \n          Authenticated() :\n          Unauthenticated(),\n      ),\n    );\n  },\n)\n\n\nUżycie Observera może wydać ci się delikatnie wybrakowane. Przecież nie powiedzieliśmy mu na jakie zmiany ma nasłuchiwać. Skąd zatem wie, które obiekty ma śledzić?\n\n\n  Wszystkie zdefiniowane w store.dart? Nie\n  Żadnego? Nie\n  Tylko te które użyte są wewnątrz buildera? Tak!\n\n\nMobX sam, bez twojego udziału zadba o to, aby rebuild nastąpił tylko wtedy, gdy zmieni się Observer użyty wewnątrz wywołania funkcji builder. Ty się niczym nie przejmuj, zrób sobie kawę i odpocznij. Co więcej - jeśli nie użyjesz żadnego Observera wewnątrz funkcji to konsola wyświetli ostrzeżenie. Skoro nic nie chcesz obserwować to po co używasz Observera?\n\n\n\nIntegracja akcji\n\nNie ma nic prostszego niż integracja UI z akcjami. Jedyne co należy zrobić to wywołać odpowiednią akcję i … gotowe. Żadnego dodatkowego wpinania kabelków i dispatcherów.\n\nPrzed:\nvoid login() {}\n\nvoid addSkill() {}\n\nvoid logout() {}\n\n\nPo:\nvoid login() =&amp;gt; store.login();\n\nvoid addSkill() =&amp;gt; store.addSkill();\n\nvoid logout() =&amp;gt; store.logout();\n\n\nUruchomienie aplikacji w obecnym stanie spowoduje, że można się do niej zalogować i wylogować. Licznik poprzednich użytkowników również poprawnie się odświeża po wylogowaniu. Działa wszystko z wyjątkiem dodawania nowej umiejętności, bo tam ciągle mamy zahardkodowane wartości, nie korzystające ze stanu.\n\nW tym fragmencie nie ma już nic odkrywczego. Ponownie korzystamy z Observera i czytamy aktualne dane o użytkowniku. Nie ma tutaj niczego nowego nie dlatego, że jestem leniwy i mi się nie chciało. To już generalnie wszystko co musisz wiedzieć, żeby zacząć budować aplikację w oparciu o MobX.\n\nclass Authenticated extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Observer(\n      builder: (_) {\n        final user = store.me;\n\n        return Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(&quot;Name: ${user.name}&quot;),\n            Text(&quot;Birth date: ${user.birthDate}&quot;),\n            Text(&quot;Skills: ${user.skills}&quot;),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n              children: [\n                RaisedButton(\n                  onPressed: addSkill,\n                  child: Text(&quot;New skill&quot;),\n                ),\n                RaisedButton(\n                  onPressed: logout,\n                  child: Text(&quot;Log out&quot;),\n                ),\n              ],\n            )\n          ],\n        );\n      }\n    );\n  }\n\n  void addSkill() =&amp;gt; store.addSkill();\n\n  void logout() =&amp;gt; store.logout();\n}\n\n\nPodsumowanie\n\nMobX jest świetnym i sprawdzonym w boju rozwiązaniem do zarządzania stanem aplikacji. Nie wymaga dużej ilości kodu, jest wydajny i sporo rzeczy dzieje się bez udziału programisty. Generowanie kodu niemal do zera redukuje ilość boilerplate, a widget Observer ze swoim auto przebudowywaniem oszczędza czasu na zastanawianiu się pod które części stanu trzeba się zarejestrować.\n\nSamo korzystanie z biblioteki ogranicza się do:\n\n  definiowania klas z wyeksponowanymi obiektami @observable i @computed\n  implementacji akcji mutujących stan @action\n  korzystanie z widgeta Observer na warstwie UI\n  pamiętaniu o przegenerowaniu kodu po zmianach (lub uruchomienia watcha)\n  polubienia immutable objects\n\n\nOsobiście MobX to dla mnie numer #1 jeśli chodzi o dostępne biblioteki do zarządzania stanem. Jest prosty, szybki i przyjemny, a są to cechy, które mocno sobie cenię zwłaszcza w pobocznych projektach robionych po godzinach. Używam go m.in. w developmencie pierwszego RPG online osadzonego w świecie post-apo we Flutterze - Vaultomb. Premiera w dalszej przyszłości :)\n"
} ,
  
  {
    "title"    : "Asynchroniczny Dart - Isolates",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/async-dart-isolates/",
    "date"     : "July 5, 2020",
    "excerpt"  : "\n  Jest to drugi wpis z serii o modelu wykonawczym w Darcie i powiązanej z nim asynchroniczności. Aby wyciągnąć maksimum wiedzy z tego wpisu, niezbędna jest wiedza z poprzedniego, który tłumaczy działanie Event Loop, Futures i programowania z użyc...",
  "content"  : "\n  Jest to drugi wpis z serii o modelu wykonawczym w Darcie i powiązanej z nim asynchroniczności. Aby wyciągnąć maksimum wiedzy z tego wpisu, niezbędna jest wiedza z poprzedniego, który tłumaczy działanie Event Loop, Futures i programowania z użyciem async/await. Znajdziesz go tutaj.\n\n\nW poprzednim wpisie do skutku wałkowany był temat tego, że Dart jest językiem jednowątkowym. Na poziomie procesora jest w stanie wykonywać tylko jedną operację w danym czasie. Nie rozdwoi się. Tylko co w takim razie zrobić, gdy mamy do wykonania bardzo ciężką operację, a nie chcemy zawiesić na czas obliczeń całej aplikacji?\n\nJest na to sposób! Nie jest to co prawda pełna wielowątkowość, ale dostarczony mechanizm umożliwia równoległe wykonywanie wielu operacji na raz. Daje nam to szansę na zapewnienie responsywności UI, a przy tym prowadzenia ciężkich obliczeń na tyłach.\n\n\n\nIsolate\n\nUruchomiona aplikacja w Darcie operuje w obrębie pojedynczego wątku, a raczej jak to się przyjęło w nomenklaturze tego języka - izolatu (Isolate). Sama nazwa nie jest jednak siłą przypadku, gdyż niesie za sobą ważną informację.  Izolaty są od siebie odizolowane i nie współdzielą pamięci.\n\nMamy możliwość tworzenia i startowania niezależnych izolatów, ale nie mogą one w żaden sposób współdzielić ze sobą nawet części wydzielonej pamięci. Ograniczenie technologiczne. Nie chodzi tutaj nawet o dwa niezależne izolaty. Rodzic, który wystartował nowego izolata również nie jest w stanie operować na jego pamięci. Absolutna izolacja.\n\nKażdy jeden izolat ma własną pamięć, własnego Event Loopa z kolejkami itd. Powinny być postrzegane jako mini osobne aplikacje, gdzie każda sobie rzepkę skrobie.\n\nW porządku, tylko jak w takim razie sterować takim nowo utworzonym izolatem? Jeśli mogę go tylko wystartować i nic więcej to po co mi on? Nawet jeśli wykona swoją ciężką pracę, to jak powie o tym głównemu wątkowi? Poprzez zadeklarowane porty, którymi wysyłane są wiadomości (messages) w obie strony.\n\nTworzenie izolata\n\nPrzejdźmy od razu do praktyki i stwórzmy program z dodatkowym izolatem.\n\nimport &quot;dart:async&quot;;\nimport &quot;dart:isolate&quot;;\n\nFuture&amp;lt;void&amp;gt; main() async {\n  final receivePort = ReceivePort();\n\n  Isolate isolate = await Isolate.spawn(\n    isolateEntry,\n    receivePort.sendPort,\n  );\n\n  receivePort.listen((dynamic message) {\n    print(&#39;Isolate says: $message&#39;);\n  });\n}\n\nvoid isolateEntry(SendPort sendPort) {\n  Timer.periodic(\n    Duration(seconds: 1), \n    (_) =&amp;gt; sendPort.send(&quot;Hi&quot;),\n  );\n}\n\n\nNa samym początku tworzony jest obiekt typu ReceivePort. Umożliwi nam to komunikację między izolatami. Następnie tworzony jest nowy izolat poprzez asynchroniczny konstruktor Isolate.spawn do którego podajemy dwa argumenty.\n\n\n  isolateEntry - funkcja startowa. Mówimy izolatowi jaka funkcja ma być jego “mainem”. Uruchamiając aplikację w Darcie, gdy wstaje pierwszy izolat, szuka on właśnie funkcji o nazwie main. Tutaj mamy już dowolność jak ją nazwiemy, ale funkcja ta musi być albo statyczna, albo tzw. top-level. Nie możesz przekazać tutaj ani metody obiektu, ani żadnej funkcji, która jest zdefiniowana wewnątrz innego bloku kodu jak np. funkcja zadeklarowana w funkcji.\n  receivePort.sendPort - obiekt typu SendPort, który otrzymujemy po utworzeniu nowego ReceivePort. Jest to port przez który wysyłane są wiadomości od dziecka do rodzica. Wysłana wiadomość trafia bezpośrednio do powiązanego z nią ReceivePort.\n\n\nOstatnią rzeczą jaką robi main jest rozpoczęcie nasłuchiwania na wszystkie przychodzące wiadomości i ich printowanie na konsolę.\n\nCo robi natomiast sam izolat? Uruchamia timer, który co sekundę wysyła wiadomość Hi na otrzymany port. Na początek wystarczy. Uruchomienie aplikacji powoduje niekończący się spam ze strony izolatu.\n\nIsolate says: Hi\nIsolate says: Hi\nIsolate says: Hi\nIsolate says: Hi\n...\n\n\nPoniżej zamieszczony jest przykład izolata, który jako punkt wejściowy otrzymuje funkcję zdefiniowaną w obrębie innej funkcji. Uruchomienie takiego programu zakończy się błędem, gdyż jedyny poprawny punkt wejścia to funkcja statyczna, lub top-level. Pamiętaj o tym!\n\nFuture&amp;lt;void&amp;gt; main() async {\n  final receivePort = ReceivePort();\n\n  void isolateEntry(SendPort port) =&amp;gt; print(&quot;Hi&quot;);\n\n  // Error!\n  Isolate isolate = await Isolate.spawn(\n    isolateEntry,\n    receivePort.sendPort,\n  );\n}\n\n\nNiezależna pamięć\n\nZróbmy szybki test dla upewnienia się, że izolaty są od siebie rzeczywiście w pełni odizolowane. Zdefiniujemy globalną flagę i zmienimy jej wartość wewnątrz izolata. Zmiana ta nie powinna wpłynąć w żaden sposób na to, co dzieje się w głównym wątku. Oba izolaty mają przecież osobną pamięć, więc flaga mimo swojej globalności będzie miała inny adres w pamięci w każdym z izolatów.\n\nimport &quot;dart:async&quot;;\nimport &quot;dart:isolate&quot;;\n\n// Define dummy flag\nbool flag = true;\n\nFuture&amp;lt;void&amp;gt; main() async {\n  final receivePort = ReceivePort();\n\n  Isolate isolate = await Isolate.spawn(\n    isolateEntry,\n    receivePort.sendPort,\n  );\n\n  receivePort.listen((dynamic message) {\n    // Print flag value within main isolate\n    print(&#39;main flag: $flag&#39;);\n    print(&#39;Isolate says: $message&#39;);\n  });\n}\n\nvoid isolateEntry(SendPort sendPort) {\n  // Change the flag value within isolate\n  flag = false;\n\n  Timer.periodic(\n    Duration(seconds: 1),\n    (_) {\n      // Print flag value within new isolate\n      print(&#39;isolate flag: $flag&#39;);\n      sendPort.send(&quot;Hi&quot;);\n    },\n  );\n}\n\n\nisolate flag: false\nmain flag: true\nIsolate says: Hi\n\nisolate flag: false\nmain flag: true\nIsolate says: Hi\n\n...\n\n\nSukces! Główny wątek widzi inną wartość flagi niż izolat którego stworzył. Dowód naukowy przedstawiony, można się rozejść kontynuować.\n\nObustronna komunikacja\n\nKomunikacja od dziecka do rodzica okazała się prosta, wystarczyło jedynie użyć ReceivePort. A jak to ma się w drugą stronę? Jak od rodzica wysłać wiadomość do dziecka? Na przykład w odpowiedzi na otrzymaną wiadomość? Kolejnym ReceivePortem!\n\nimport &quot;dart:async&quot;;\nimport &quot;dart:isolate&quot;;\n\nFuture&amp;lt;void&amp;gt; main() async {\n  final receivePort = ReceivePort();\n\n  Isolate isolate = await Isolate.spawn(\n    isolateEntry,\n    receivePort.sendPort,\n  );\n\n  // Define send port of child isolate\n  SendPort isolatePort;\n  receivePort.listen((dynamic message) {\n    if (message is SendPort) {\n      isolatePort = message;\n      return;\n    }\n\n    print(&#39;Isolate says: $message&#39;);\n\n    if (isolatePort != null) {\n      // Reply with message after small delay\n      Future.delayed(\n        Duration(milliseconds: 500),\n        () =&amp;gt; isolatePort.send(&quot;Hello&quot;),\n      );\n    }\n  });\n}\n\nvoid isolateEntry(SendPort sendPort) {\n  // Create own ReceivePort and send it to the parent immediately\n  final receivePort = ReceivePort();\n  receivePort.listen((dynamic message) {\n    print(&#39;Parent says: $message&#39;);\n  });\n\n  sendPort.send(receivePort.sendPort);\n\n  Timer.periodic(\n    Duration(seconds: 1),\n    (_) =&amp;gt; sendPort.send(&quot;Hi&quot;),\n  );\n}\n\n\nNa poziomie funkcji main zdefiniowaliśmy nową zmienną isolatePort typu SendPort do której przypiszemy port z izolata jak tylko nam go wyśle. Wysyłka jest realizowana przez ten sam port komunikacyjny którym przychodzą wiadomości tekstowe. W momencie otrzymania obiektu sprawdzamy jego typ, aby ustalić co dokładnie wysłał nam izolat. Ustawiamy wartość portu, lub printujemy wiadomość i wysyłamy z małym opóźnieniem odpowiedź zwrotną.\n\nZ kolei isolateEntry tworzy własny ReceivePort, nasłuchuje na nim, a następnie wysyła go od razu do swojego rodzica. Ma to miejsce jeszcze przed pierwszym wysłaniem napisu Hi.\n\nWyszło całkiem sporo kodu jak na tak prosty program, który jedyne co robi to ping-ponga z wiadomościami. Pokazuje jednak najważniejsze aspekty pracy z izolatami, czyli jak wymieniać się informacjami i wzajemnie wpływać na siebie. Czy pozostało coś jeszcze? O tak! Samoistne zakończenie programu i posprzątanie śmieci.\n\nZamykanie izolata\n\nGdy zaczniesz już korzystać z izolatów we własnej aplikacji, proszę pamiętaj żeby je zabić gdy nie są już potrzebne. Szkoda zasobów maszyny żeby wisiały bez końca, a przy odpowiednich okolicznościach mocno wpłyną na wydajność głównego wątku.\n\nIzolat udostępnia sugestywną metodę kill(), która go uśmierci na zawołanie. Kiedy ją zawołać? W momencie gdy izolat wykonał swoją pracę i nie będziesz go więcej potrzebował. Brutalne, ale tak działa ich świat. W przykładzie poniżej niszczę wszystko i zamykam strumień danych po dokładnie trzech wiadomościach. Zamykanie strumienia receivePort jest opcjonalne, ale bez tego aplikacja zatrzyma się w limbo i trzeba ją będzie nadal ubijać ręcznie.\n\nimport &quot;dart:async&quot;;\nimport &quot;dart:isolate&quot;;\n\nFuture&amp;lt;void&amp;gt; main() async {\n  final receivePort = ReceivePort();\n\n  Isolate isolate = await Isolate.spawn(\n    isolateEntry,\n    receivePort.sendPort,\n  );\n\n  SendPort isolatePort;\n  int count = 0;\n  receivePort.listen((dynamic message) {\n    if (message is SendPort) {\n      isolatePort = message;\n      return;\n    }\n\n    print(&#39;Isolate says: $message&#39;);\n\n    if (isolatePort != null) {\n      Future.delayed(\n        Duration(milliseconds: 500),\n        () =&amp;gt; isolatePort.send(&quot;Hello&quot;),\n      );\n    }\n\n    // Kill isolate with fire!\n    if (++count == 3) {\n      isolate.kill(priority: Isolate.immediate);\n      isolate = null;\n      receivePort.close();\n    }\n  });\n}\n\nvoid isolateEntry(SendPort sendPort) {\n  final receivePort = ReceivePort();\n  receivePort.listen((dynamic message) {\n    print(&#39;Parent says: $message&#39;);\n  });\n\n  sendPort.send(receivePort.sendPort);\n\n  Timer.periodic(\n    Duration(seconds: 1),\n    (_) =&amp;gt; sendPort.send(&quot;Hi&quot;),\n  );\n}\n\n\nFlutter vs Isolate\n\nPraca z izolatami nie należy do najprzyjemniejszych i wymaga od programisty dużej ilości kodu. Tworzenie izolata, portów, nasłuchiwanie, sprzątanie. Kawał roboty, zwłaszcza gdy najczęściej chcemy po prostu wykonać pewien fragment kodu w taki sposób, żeby nie zawiesił naszego UI i zwrócił wynik jak skończy.\n\nFlutter jak to często bywa dostarcza gotowe rozwiązanie w postaci funkcji compute, która:\n\n\n  Startuje nowego izolata\n  Uruchamia w jego obrębie wskazaną funkcję z zadanymi parametrami\n  Gdy przetwarzanie dobiegnie końca zwracany jest wynik (asynchronicznie)\n  Izolat ulega zniszczeniu, wszystko jest posprzątane\n\n\nJak wygląda jej użycie? Stwórzmy do tego prostą aplikację Flutterową, żeby zademonstrować jaka jest różnica między aplikacją nieresponsywną (bez izolata), a responsywną (z izolatem).\n\nSortownik\n\nSortownik to banalna aplikacja do sortowania liczb. Nie wykorzysta ona jednak żadnego znanego i wydajnego algorytmu sortowania, a zamiast tego stworzymy najmniej wydajne rozwiązanie jakie widział świat. Wszystko po to, aby zasymulować sytuację w której mamy do wykonania zadanie mocno obciążające moc obliczeniową urządzenia.\n\nUI\n\nInterfejs jest toporny do granic możliwości. Żadnych styli, kolorów, nic. Wyświetlamy zaledwie dwie listy: wejściową i posortowaną oraz dwa przyciski, gdzie jeden odpowiedzialny jest za przesortowanie, a drugi aktualizuje po stuknięciu licznik o 1.\n\n\n\nAktualny algorytm sortowania jest optymalny - robi robotę, szybciej się nie da. W następnym kroku wymienimy go na autorskie rozwiązanie typu “w końcu się musi udać”.\n\nimport &#39;package:flutter/foundation.dart&#39;;\nimport &#39;package:flutter/material.dart&#39;;\n\nvoid main() =&amp;gt; runApp(MyApp());\n\nclass MyApp extends StatefulWidget {\n  @override\n  _MyAppState createState() =&amp;gt; _MyAppState();\n}\n\nclass _MyAppState extends State&amp;lt;MyApp&amp;gt; {\n  final List&amp;lt;int&amp;gt; unsortedList = [\n    1, 3, 2, 4, 3, 5, 7, 4, 5, 6, 12,\n  ];\n  bool sorting = false;\n  int counter = 0;\n  List&amp;lt;int&amp;gt; sortedList;\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              Text(&#39;$unsortedList&#39;),\n              SizedBox(height: 24),\n              if (sorting)\n                Text(&#39;Sorting ...&#39;)\n              else\n                Text(&#39;Sorted: $sortedList&#39;),\n              SizedBox(height: 24),\n              RaisedButton(\n                onPressed: () =&amp;gt; sortList(),\n                child: Text(&#39;Sort&#39;),\n              ),\n              RaisedButton(\n                onPressed: () =&amp;gt; increaseCounter(),\n                child: Text(&#39;Counter: $counter&#39;),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  void increaseCounter() {\n    setState(() {\n      counter++;\n    });\n  }\n\n  Future&amp;lt;void&amp;gt; sortList() async {\n    // Update UI to reflect the sort has started\n    setState(() {\n      sorting = true;\n    });\n\n    setState(() {\n      sortedList = sortNumbers(unsortedList);\n    });\n\n    // Update UI to reflect the sort has finished\n    setState(() {\n      sorting = false;\n    });\n  }\n}\n\nList&amp;lt;int&amp;gt; sortNumbers(List&amp;lt;int&amp;gt; numbers) {\n  return [...numbers]..sort();\n}\n\n\nAlgorytm sortujący\n\nW obecnym stanie aplikacja jest w 100% responsywna i zapewnia 60 klatek na sekundę. Nie jest to specjalne osiągnięcie patrząc na jej możliwości, ale za chwilę będzie już tylko gorzej.\n\nPora wymienić domyślne sortowanie na własny mechanizm:\n\nList&amp;lt;int&amp;gt; sortNumbers(List&amp;lt;int&amp;gt; numbers) {\n  final easy = [...numbers]..sort();\n  final sorted = [...numbers]..shuffle();\n\n  while (!listEquals(easy, sorted)) {\n    sorted.shuffle();\n  }\n\n  return sorted;\n}\n\n\nAlgorytm jest fantastyczny w swojej prostocie. Na początku sortuje otrzymaną listę i zapisuje ją w zmiennej easy. Następnie tasuje oryginalną listę poprzez losowe ustawienie elementów. Ostatni krok to powtarzanie losowego tasowania, aż trafi na wariant posortowany. Genialne. Czasochłonne, ale genialne.\n\nPo uruchomieniu zaktualizowanej aplikacji i stuknięciu w przycisk Sort następuje całkowite zamrożenie UI do czasu uzyskania wyniku. Stukanie w przycisk Counter nie reaguje, a dla użytkownika wygląda to tak, jakby aplikacja się kompletnie zawiesiła. A przecież tak nie jest! Robimy ważne obliczenia i jak tylko skończymy to UI wróci do normy.\n\nJeśli interfejs zawiesił się na dobre - skróc listę unsortedList o element, albo dwa i zrestartuj aplikację. U mnie taka długość jest optymalna żeby czekać średnio kilka sekund na posortowanie, ale co konfiguracja to inne opóźnienie.\n\n\n  Zła wiadomość jest taka, że istnieje duże prawdopodobieństwo na to, że UI nigdy nie wróci do normy. Użytkownik może nie wytrzymać i usunie w między czasie aplikację.\n\n\nEvent Loop\n\nSpróbujmy uruchomić funkcję asynchronicznie, na Event Loopie!\n\nFuture(() {\n  setState(() {\n    sortedList = sortNumbers(unsortedList);\n  });\n});\n\n\nZła wiadomość #2. Pamiętasz, że jeden wątek to jedna instrukcja w danym czasie? To, że uruchomimy ten kod przez Event Loop nic nam nie da, bo to wciąż ten sam wątek, a zadanie jest związane ściśle z mocą procesorą.\n\ncompute\n\nSkoro jeden wątek to jedna instrukcja, pora uruchomić pomocnika w postaci izolata. Nie będziemy go jednak tworzyć ręcznie, bo opisany compute sprawdzi się tutaj doskonale. Nie potrzebujemy przecież stałej komunikacji w obie strony. Wystarczy, że funkcja uruchomi się z zadanymi parametrami i dostarczy wynik gdy będzie już gotowy.\n\nfinal sorted = await compute(\n  sortNumbers, unsortedList,\n);\nsetState(() {\n  sortedList = sorted;\n});\n\n\nPełny kod funkcji sortList:\n\nFuture&amp;lt;void&amp;gt; sortList() async {\n  // Update UI to reflect the sort has started\n  setState(() {\n    sorting = true;\n  });\n\n  final sorted = await compute(\n    sortNumbers, unsortedList,\n  );\n  setState(() {\n    sortedList = sorted;\n  });\n\n  // Update UI to reflect the sort has finished\n  setState(() {\n    sorting = false;\n  });\n}\n\n\nUruchamiana jest tutaj funkcja sortNumbers z argumentem unsortedList, która będzie działać na osobnym izolacie. Zwracany jest obiekt typu Future&amp;lt;List&amp;lt;int», więc czekamy na jego wynik na Event Loopie głównego wątku. Różnica między poprzednim rozwiązaniem, a obecnym, polega na przeprowedzaniu sortowania w osobnym izolacie. Dzięki temu główny wątek odpowiedzialny m.in. za renderowanie UI pozostaje w pełni responsywny i użytkownik może w dowolnym momencie zwiększyć licznik stukając w przycisk.\n\nPodsumowanie\n\nDart pomimo jednowątkowości udostępnia mechanizm do tworzenia dodatkowych wątków w postaci izolatów. Nie dzielą one co prawda między sobą pamięci, ale jest to świetny sposób na wykonywanie ciężkich operacji, które w przeciwnym wypadku mogłyby wpłynąć na wydajność całej aplikacji.\n\nKiedy warto skorzystać z izolata zamiast kodu asynchronicznego i Event Loopa? Zawsze, gdy wykonywana jest mocno obciążająca operacja taka jak skomplikowane wyliczenia, czy wykonywanie manipulacji na zdjęciach lub video. Każda aplikacja jest inna i ma własne scenariusze, dlatego trudno jednoznacznie powiedzieć którego rozwiązania użyć i kiedy.\n\nKorzystaj ze standardowego kodu asynchronicznego tak długo jak nie odczuwasz spowolnionego działania aplikacji. Póki jest szybka i responsywna nie ma potrzeby aby urchamiać dodatkowy izolat. Zwłaszcza, że ewentualne przerobienie kodu na compute() nie jest pracochłonne.\n\nJest to drugi wpis z serii dotyczącej przetwarzanie instrukcji w aplikacjach Flutterowych. W planach jest jeszcze jeden, traktujący o strumieniach i jemu pochodnych. Do następnego!\n\nKod pełnej aplikacji Sortownik znajdziesz na GitHubie.\n"
} ,
  
  {
    "title"    : "Asynchroniczny Dart - Event Loop, Futures, async/await",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/async-dart-event-loop-futures/",
    "date"     : "June 27, 2020",
    "excerpt"  : "Pisząc dowolną aplikację we Flutterze posługujesz się językiem Dart. Wszystkie ograniczenia i subtelności zdefiniowane w samym języku, będą ci również towarzyszyły we Flutterze. Nie da się inaczej. Flutter stoi na Darcie, koniec i kropka. Czy to d...",
  "content"  : "Pisząc dowolną aplikację we Flutterze posługujesz się językiem Dart. Wszystkie ograniczenia i subtelności zdefiniowane w samym języku, będą ci również towarzyszyły we Flutterze. Nie da się inaczej. Flutter stoi na Darcie, koniec i kropka. Czy to dobrze? Jasne, czemu nie. Lubię ten język i mam do niego pewnego rodzaju słabość, ale warto poznać go czasem nieco głębiej poza samą jego składnią.\n\nNie będziemy jednak wertować całego języka od podstaw, od tego jest oficjalna dokumentacja. Skupimy się jedynie na tym skąd Dart wie który kod uruchomić w jakim czasie oraz na czym opiera się cała magia asynchroniczności. Temat jest bardzo szeroki i wymaga zrozumienia kilku podstawowych konceptów od których rozpoczniemy dzisiejszy wpis.\n\n\n\nJednowątkowy Dart\n\nTak jest, zgadza się. Dart jest językiem jednowątkowym, tak jak wiele innych popularnych języków programowania jak chociażby JavaScript, czy Python. A co to tak na prawdę oznacza?\n\n\n  Jakieś wątki pewnie i że jest jeden?\n\n\nBingo! Z samej nazwy można praktycznie wszystko wywnioskować. Aplikacja pisana w Darcie wykonuje wszystkie swoje operacje w obrębie pojedynczego wątku systemowego. A skoro wątek jest tylko jeden, to program może robić tylko jedną rzecz w danym punkcie czasu. Wykona jedną operację, później drugą, trzecią itd. Nie ma tutaj mowy o żadnym zrównoleglaniu prac żeby w tym samym momencie robić rzeczy A, B i C. Zapomnij.\n\nPierwsze wyobrażenie o takim sposobie wykonywania operacji przynosi obraz powolności. No bo jak to tak? Nie można robić wielu rzeczy na raz? Przecież ŻADNA aplikacja nie może tak działać. To się nie może udać! A jednak się udaje i aplikacje pisane we Flutterze bez problemów osiagają mityczne 60 klatek na sekundę. Jak to się dzieje? O tym już za chwilę.\n\nSam aspekt jednowątkowości ma z mojej perspektywy dwie zasadnicze zalety. Pierwszą jest to, że aktualnie wykonywany kod nie może zostać przez nic przerwany. Tylko jeden wątek ma dostęp do pamięci, więc tylko on steruje tym co się wewnątrz dzieje. Nikt z zewnątrz nie może nagle wskoczyć i zmienić czegokolwiek, jak chociażby wartości obiektów. Drugą natomiast zaletą jest brak deadlocków i wyścigów w dostępie do pamięci, gdy w dokładnie tym samym momencie jest kilku zainteresowanych danym obszarem jak np. zmiana wartości współdzielonej zmiennej.\n\n\n  Jeden wątek to w praktyce mniej zmartwień.\n\n\nimport &quot;package:flutter/foundation.dart&quot;;\n\nbool flag = true;\n\nvoid main() {\n  print(&quot;start main&quot;);\n  print(randomSort([2,1,3,4,5,6,7,8,9,10]));\n  print(&quot;end main, flag: $flag&quot;);\n}\n\n\nList&amp;lt;int&amp;gt; randomSort(List&amp;lt;int&amp;gt; numbers) {\n  final easy = [...numbers]..sort();\n  final sorted = [...numbers]..shuffle();\n  \n  while (!listEquals(easy, sorted)) {\n    sorted.shuffle();\n  }\n  \n  return sorted;\n}\n\n\nPowyższy kod gwarantuje, że wszystkie instrukcje począwszy od pierwszego printa, przez dziwny algorytm sortowania, aż po ostatniego printa zostaną wykonane jedno po drugim. Co więcej - żaden inny kod nie zostanie uruchomiony w między czasie, bez znaczenia jak bardzo byśmy wszystko skomplikowali. Znaczy to tyle, że zmienna flag na pewno będzie miała wartość true, bo żaden inny kod nie ma prawa być uruchomiony do momentu zakończenia wszystkich synchronicznych operacji.\n\nSynchroniczność\n\nWspomniane operacje synchroniczne to model ich wykonywania w którym każde kolejne zadanie następuje bezpośrednio po sobie i nie ma w nim miejsca na żadne działania dodatkowe. Przez zadanie mam na myśli pojedynczą instrukcję, dla uproszczenia możemy przyjąć że jest to po prostu jedna linia kodu.\n\n\n  Uruchamiamy zadanie #1\n  Przetwarzamy je i uzyskujemy wynik\n  Uruchamiamy zadania #2\n  Przetwarzamy je i uzyskujemy wynik\n\n\n…\n\nn. Uruchamiamy ostatnie zadanie, przetwarzamy i uzyskujemy wynik\n\nJest to model którego używamy w większości miejsc aplikacji, łatwo można prześledzić co i kiedy jest wykonywane. No bo skoro wykonuje się teraz linia #45, to następna musi być #46. Nie ma innej możliwości, łatwizna.\n\nMa on jednak zasadniczą wadę, a mianowicie szansę na zablokowanie programu podczas oczekiwanie na wolne zdarzenie takie jak odczyt danych z sieci, czy nawet lokalnego pliku. Chyba nie chcesz zawiesić całej aplikacji na czas gdy odpytujesz swoje API? Jeden wątek, jedno zadanie, a czekanie to też praca w modelu synchronicznym.\n\nGwarantuję ci, że użytkownik nie będzie wyrozumiały i jest mało zainteresowany faktem jednowątkowości. Ma być szybko i responsywnie! Czyli jak? Asynchronicznie!\n\n\n\n  Idziesz do kina na swój ulubiony film. Ustawiasz się w kolejce po bilet i czekasz aż wszystkie osoby przed tobą zostaną obsłużone i zostanie wydany im bilet. Teraz pora na ciebie, możesz kupić bilet i cieszyć się seansem.\n\n\nAsynchroniczność\n\nKod napisany w sposób asynchroniczny różni się od swojego synchronicznego odpowiednika tym, że nie jest w pełni wykonywany “ciągiem”. A przynajmniej nie ma takiej gwarancji. Funkcja asynchroniczna ma możliwość oddania sterowania i wykonywania operacji do innego miejsca w kodzie. Mechanizm ten nie odbywa się oczywiście w sposób losowy i to my pisząc kod wskazujemy na konkretne miejsca, które w czasie oczekiwania na COŚ mają zwolnić wątek i dokończyć zaplanowane zadania w momencie gdy to COŚ będzie już gotowe.\n\n\n  Czekanie to nie praca. Odpoczywasz? Daj szansę innym zrobić coś produktywnego!\n\n\nCzym będzie to COŚ na prawdziwym przykładzie? W dzisiejszych aplikacjach są to najczęściej operacje wejścia-wyjścia (I/O), które z natury nie wymagają udziału procesora, więc mogą go zwolnić dla bardziej potrzebujących:\n\n  obsługa API, bez znaczenia czy to REST API, GraphQL, czy jeszcze coś innego. Istotnym punktem jest to, że zachodzi tutaj ruch sieciowy.\n  odczyt/zapis lokalnych plików, gdzie praca wykonywana jest przez urządzenie dyskowe, a nie procesor.\n\n\nSama asynchroniczność nie ogranicza się jednak do wyżej wymienionych i po prawdzie to każda operacja może być wykonana w taki właśnie sposób.\n\nPamiętaj przy tym o jednej bardzo, ale to bardzo ważnej rzeczy. Dart nadal pozostaje jednowątkowy! To, że zaplanujesz kod do wykonania asynchronicznego nie znaczy, że będzie wykonywał wiele operacji w jednym czasie. Dalej na poziomie procesora jest ograniczony do “jedna rzecz w jednym czasie”, a cała magia asynchroniczności opiera się na wewnętrznej kolejce zdarzeń zwanej Event Loop.\n\n\n\n  Idziesz do restauracji na swoje ulubione naleśniki. Lokal jest już w połowie zapełniony ludźmi którzy czekają na swoje zamówienia, a mimo to kelner podchodzi i przyjmuje twoje. Co więcej, wcale nie musisz czekać aż dania zostaną wydane wszystkim którzy zamówili wcześniej. Nie blokuje cię więc pan ze stolika #2, który poprosił o pieczonego prosiaka którego przygotowanie zajmie ponad 2h. Ma to sens, prawda?\n\n\nEvent Loop\n\nUruchamiając dowolny program Darta, a więc m.in. aplikację Flutterową, system tworzy nowy wątek w obrębie którego wykonywane będą wszystkie zaprogramowane operacje. W tym właśnie wątku będzie alokowana cała niezbędna pamięć dla twoich obiektów, której nie będziesz mógł współdzielić z żadnym innym wątkiem. Zasada jednowątkowości.\n\nW ramach startowania aplikacji, jedną z pierwszych rzeczy która się wydarzy jest inicjalizacja wewnętrznej pętli zwanej Event Loop, która będzie trwała tak długo jak żyje sam wątek. To właśnie ten element układanki jest odpowiedzialny za kolejność w której uruchamiany jest kod programu, szczególnie gdy rozmawiamy o jego asynchronicznej odmianie.\n\nvoid eventLoop() {\n  while (true) {\n    final microtask = popMicrotaskFromQueue();\n\n    if (microTask) {\n      run(microTask);\n    } else {\n      final event = popEventFromQueue();\n\n      if (event) {\n        run(event);\n      }\n    }\n  }\n}\n\n\nEvent Loop zarządza swoim stanem w formie dwóch bliźniaczo podobnych kolejek FIFO (First In First Out), gdzie zadania wykonywane są w takiej kolejności w jakiej zostały do niej dodane.\n\nMicrotask Queue\n\nKolejka o wysokim priorytecie do zadań specjalnych, których najpewniej nie będziesz potrzebował przy budowaniu aplikacji. Szczerze powiedziawszy to nigdy nie użyłem jej produkcyjnie, nie było takiej potrzeby. Jej głównym zastosowaniem jest zaplanowanie wykonania pewnego fragmentu kodu asynchronicznie, ale przed wywołaniem jakiegokolwiek kodu umieszczonego na Event Queue.\n\nvoid main() {\n  print(&quot;start main&quot;);\n  scheduleMicrotask(() =&amp;gt; print(&quot;micro&quot;));\n  print(&quot;end main&quot;);\n}\n\n\nPo uruchomieniu powyższego kodu zobaczysz następującą kolejność w konsoli:\n\n1. start main\n2. end main\n3. micro\n\n\nNapis micro jest na pozycji #3, a nie #2, ponieważ jest wykonywany asynchronicznie. Wywołujemy funkcję scheduleMicrotask, która jako parametr otrzymuje funkcję, która jest niezwłocznie umieszczana na kolejce, ale nie wykonywana! Dopiero, gdy wykonają się wszystkie operacje synchroniczne, Event Loop decyduje o uruchomieniu kolejnego zadania z kolejki, którym jest właśnie ostatni print.\n\nEvent Queue\n\nKolejka o standardowym priorytecie, która zawsze ma dużo pracy i zadań do wykonania. To właśnie tutaj odbywa się większość operacji asynchronicznych każdej aplikacji mobilnej. Na tym poziomie obsługiwane są takie zdarzenia jak gesty użytkownika, odpowiedzi na żądania HTTP, czy timery. Użytkownik stuknął palcem w przycisk? Event. Użytkownik skroluje listę? Dużo eventów. Przyszła w końcu wyczekiwana odpowiedź z serwera na którą tak długo czekałeś? Event. I tak bez końca.\n\nJak wykonać kod na tej kolejce? Może jakiś analogiczny scheduleEvent? Byłoby spójnie, ale interfejs jest delikatnie inny. W celu zaplanowania zdarzenia asynchronicznego musisz stworzyć obiektu typu Future. Pora na większą ilość praktyki, a co za tym idzie kodu!\n\n\n  W świecie Fluttera mówi się, że wszystko jest widgetem. Teraz już wiesz że to kłamstwo, bo wszystko jest tak na prawdę eventem.\n\n\nFuture\n\nW celu zaplanowania i uruchomienia dowolnego kodu na kolejce asynchronicznej tworzymy nowy obiekt typu Future. Jeśli pisałeś wcześniej w JavaScript to sposób działania jest identyczny jak w przypadku obiektu Promise. A jeśli nie pisałeś? Spójrzmy:\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&quot;start main&quot;);\n  Future(() =&amp;gt; print(&quot;future&quot;));\n  scheduleMicrotask(() =&amp;gt; print(&quot;micro&quot;));\n  print(&quot;end main&quot;);\n}\n\n\n1. start main\n2. end main\n3. micro\n4. future\n\n\nPrinty 1 oraz 2 to kod uruchamiany synchronicznie. micro wskakuje jako 3, ponieważ kolejka microtask ma pierwszeństwo przed jakimkolwiek zadaniem na kolejce event. Ostatni jest sam future.\n\nSpójrzmy jeszcze na przykład z większą liczbą zdarzeń:\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&quot;start main&quot;);\n  Future(() =&amp;gt; print(&quot;future1&quot;));\n  Future(() =&amp;gt; print(&quot;future2&quot;));\n  Future(() =&amp;gt; print(&quot;future3&quot;));\n  print(&quot;end main&quot;);\n}\n\n\n1. start main\n2. end main\n3. future1\n4. future2\n5. future3\n\n\nNie ma tutaj żadnego zaskoczenia, a jedynie potwierdzenie faktu że zdarzenia są dodawane do kolejki i uruchamiane w odpowiedniej kolejności future1 -&amp;gt; future2 -&amp;gt; future3. Wcześniej dodane zdarzenie oznacza szybsze jego podjęcie i wykonanie.\n\nWarto również przypomnieć raz jeszcze fakt jednowątkowości. To, że zaplanowaliśmy 3 zdarzenia nie oznacza wcale że będą one wykonywane równolegle (parallel execution), tylko asynchronicznie (asynchronous execution). Jedno po drugim, ze złudzeniem że wszystko to odbywa się w jednym czasie. Iluzja wielowątkowości.\n\nFuture.delayed\n\nFuture udostępnia pomocny konstruktor Future.delayed do zaplanowania zdarzenia, które zostanie wykonane po zadanym czasie. Zdarza mi się nie raz korzystać z tego zapisu, aby zasymulować opóźnienie jak np. przy pobieraniu danych z sieci. Samo działanie jest stosunkowo proste. Pod spodem rejestrowany jest licznik, który dokładnie po upływie zadanego okresu wrzuci do Event Loopa nowe zadanie do wykonania.\n\nSpójrz na poniższy przykład. Funkcje randomSort i listsAreEqual śmiało ignoruj, bo są tutaj tylko po to, aby wprowadzić wolny kod o losowej złożoności.\n\nvoid main() {\n  Future(() =&amp;gt; print(&quot;future1&quot;));\n  Future.delayed(\n    Duration(milliseconds: 500),\n    () =&amp;gt; print(&quot;future delayed&quot;),\n  );\n  randomSort([2,1,3,4,5,6,7,8,9,10]);\n  Future(() =&amp;gt; print(&quot;future2&quot;));\n}\n\n\nList&amp;lt;int&amp;gt; randomSort(List&amp;lt;int&amp;gt; numbers) {\n  final easy = [...numbers]..sort();\n  final sorted = [...numbers]..shuffle();\n  \n  while (!listsAreEqual(easy, sorted)) {\n    sorted.shuffle();\n  }\n  \n  return sorted;\n}\n\nbool listsAreEqual(l1, l2) {\n  return List.generate(\n    l1.length, (i) =&amp;gt; l1[i] == l2[i]\n  ).where((r) =&amp;gt; r)\n  .toList().length == l1.length;\n}\n\n\nJaka będzie kolejność wykonania?\n\nA.\n1. future1\n2. future delayed\n3. future2\n\n\nB.\n1. future1\n2. future2\n3. future delayed\n\n\nWszystko zależy od tego ile akurat zajmie posortowanie listy. Więcej niż 500ms? A. Mniej? B.\n\nFuture i jego API\n\nPowyższe przykłady wyglądają tak, jakby jedyna różnica w udostępnionym interfesie między microtask, a event polegała na słownictwie. W pierwszym mamy wywołanie funkcji scheduleMicrotask, a w drugim zawołanie Future. Z tym, że ten Future() to konstruktor, który utworzy nowy obiekt zdarzenia i zwróci nam go abyśmy mogli na nim dalej pracować i nim zarządzać. W przypadku microtask nie mamy takiego komfortu, gdyż zwraca nam on nic, czyli void.\n\nŚwieżo utworzony Future znajduje się w stanie zarejestrowanym, ale nie wykonanym. Event Loop wie już o jego istnieniu i wrzucił go na kolejkę Event Queue, ale w żadnym wypadku nie wykonuje zawartych w nim instrukcji. Na to przyjdzie pora w przyszłości (future) i kiedy ona nadejdzie stan automatycznie przejdzie w wykonany.\n\nŁańcuch wywołań (then)\n\nObiekt typu Future udostępnia funkcję then, która zostanie zawołana niezwłoczenie po tym, gdy wszystkie zawarte w nim instrukcje zostaną poprawnie wykonane. Taki sygnał zwrotny (callback) do poinformowania aplikacji, że wszystko poszło gładko i zwrócenia ostatecznego wyniku operacji.\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&quot;start main&quot;);\n  \n  Future(() {\n    print(&quot;future1&quot;);\n    return &quot;future1 completed&quot;;\n  }).then((msg) =&amp;gt; print(msg));\n  Future(() =&amp;gt; print(&quot;future2&quot;));\n\n  print(&quot;end main&quot;);\n}\n\n\n1. start main\n2. end main\n3. future1\n4. future1 completed\n5. future2\n\n\nWarto zapamiętać, że then jest uruchamiany w sposób synchroniczny, zaraz po tym jak wykona się ostatnia zaplanowana instrukcja wewnątrz aktualne przetwarzanego zdarzenia. To dlatego future1 completed wywoła się przed future2.\n\nAle super jest ten then! Tylko po co go używać skoro równie dobrze można wszystko zapisać następująco:\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&quot;start main&quot;);\n\n  Future(() {\n    print(&quot;future1&quot;);\n    print(&quot;future1 completed&quot;);\n  });\n  Future(() =&amp;gt; print(&quot;future2&quot;));\n\n  print(&quot;end main&quot;);\n}\n\n\nWynik identyczny, więc o co chodzi? O szczegół implementacyjny. Wyobraź sobie teraz, że nie piszesz własnego future tylko używasz wbudowanego w bibliotekę, powiedzmy do wysłania zapytania do API. Przykład banalny, ale świetnie obrazuje kiedy używany jest then i że pełni on kluczową rolę w przetwarzaniu asynchronicznym.\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  http.get(&quot;http://moje_api/users&quot;)\n    .then((users) =&amp;gt; print(users));\n}\n\n\nWysyłamy zapytanie na adres http://moje_api/users i jak tylko pojawi się odpowiedź (może minąć nawet kilka sekund) pokazujemy ją na konsoli. Tadam, po to jest then.\n\nWszystko jest piękne tak długo jak nie ma żadnych błędów, a dobrze wiemy że takie aplikacje nie istnieją. Błąd zawsze przyjdzie i wskoczy znienacka na użytkownika w najmniej testowanym scenariuszu. Nie sprawdziłeś jak aplikacja się zachowa przy wyciąganiu danych z API, gdy nie ma internetu? A no tak, przy developmencie przecież zawsze jesteś wpięty w firmowe wi-fi :)\n\nObsługa błędów (catchError)\n\nA skoro już o błędach mówimy to Future jest o tyle specyficznym konstruktem, że łapaniem jego wyjątków nie zajmuje się uniwersalny blok try-catch.\n\nJaki będzie wynik uruchomienia takiego programu?\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&quot;start main&quot;);\n\n  try {\n    Future(() {\n      int.parse(&quot;future&quot;);\n    });\n  } catch (_) {\n    print(&quot;ooops&quot;);\n  }\n\n  print(&quot;end main&quot;);\n}\n\n\n1. start main\n2. end main\nUnhandled exception:\nFormatException: ...\n\n\nDelikatnie zaskakujące, ale try-catch nie obsłużył wyjątku i zamiast ładnego ooops aplikacja się crashuje. Bardzo niedobrze, ale na logikę to uzasadnione działanie. Blok złapie jedynie wyjątek tworzenia samego obiektu Future, a nie jego funkcji która uruchomi się gdzieś-kiedyś, a na pewno nie w aktualnym przebiegu Event Loopa. Jest to duża pułapka o której programista często zapomina, co udowadnia np. kod z oficjalnej paczki do obsługi Cloud Functions (Firebase):\n\n\n\nJest try-catch? Jest. Jest Future? Jest, co sugeruje użycie then. Jest złapany wyjątek w razie problemów? Nie ma. Zdarza się jak widać nawet najlepszym, ale jak w takim razie obsłużyć błędy we właściwy sposób?\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&quot;start main&quot;);\n\n  Future(() {\n    int.parse(&quot;future&quot;);\n  }).catchError((_) {\n    print(&quot;ooops&quot;);\n  });\n\n  print(&quot;end main&quot;);\n}\n\n\n1. start main\n2. end main\n3. ooops\n\n\nZ użyciem funkcji catchError! Analogicznie jak then uruchamiany jest w momencie gdy wszystko przebiegło poprawnie, tak catchError zostanie wywołany jeśli funkcja rzuciła w dowolnym momencie wyjątkiem. Taki try-catch w wersji funkcyjnej.\n\nTest!\n\nCzas na kartkówkę i skondensowanie całej wiedzy w jednym przykładzie. Pochodzi on ze świetnego artykułu na temat asynchroniczności w Darcie, który serdecznie polecam. To jak, gotowy? Skompiluj w głowie poniższy kod i ustal poprawną kolejność wykonania. Zaliczenie tak złożonego przykładu udowadnia że kolejność uruchamiania kodu nie stanowi dla ciebie już żadnego wyzwania. Poważnie, nie ma już niczego więcej!\n\nimport &quot;dart:async&quot;;\n\nvoid main() {\n  print(&#39;start main&#39;);\n  scheduleMicrotask(() =&amp;gt; print(&#39;micro1&#39;));\n\n  Future.delayed(\n    Duration(seconds: 1),\n    () =&amp;gt; print(&#39;future1&#39;),\n  );\n\n  Future(() {\n    print(&#39;future2&#39;);\n  }).then((_) {\n    print(&#39;future2.1&#39;);\n  }).then((_) {\n    print(&#39;future2.2&#39;);\n    scheduleMicrotask(() =&amp;gt; print(&#39;future2.micro1&#39;));\n  }).then((_) =&amp;gt; print(&#39;future2.3&#39;));\n\n  scheduleMicrotask(() =&amp;gt; print(&#39;micro2&#39;));\n\n  Future(() {\n    print(&#39;future3&#39;);\n  }).then((_) {\n    Future(() =&amp;gt; print(&#39;future3.1&#39;));\n  }).then((_) {\n    print(&#39;future3.2&#39;);\n  });\n\n  Future(() =&amp;gt; print(&#39;future4&#39;));\n  scheduleMicrotask(() =&amp;gt; print(&#39;micro3&#39;));\n  print(&#39;end main&#39;);\n}\n\n\nGotowy?\n\nOto prawidłowa odpowiedź:\n\n1. start main\n2. end main\n3. micro1\n4. micro2\n5. micro3\n6. future2\n7. future2.1\n8. future2.2\n9. future2.3\n10. future2.micro1\n11. future3\n12. future3.2\n13. future4\n14. future3.1\n15. future1\n\n\nJak do tego doszło? Główne zasady dla przypomnienia:\n\n  Kod synchroniczny nie może zostać przerwany.\n  Gdy Event Loop dostaje sterowanie to najpierw uruchamia wszystkie microtaski na kolejce.\n  Future muszą czekać aż kolejka microtasków się opróżni.\n  Wywołanie then działa w sposób synchroniczny, Event Loop nie dostaje jeszcze możliwości dalszego sterowania.\n  Future.delayed jest opóźniony.\n\n\nasync / await\n\nStandardowa składnia do pracy z kodem asynchronicznym ma dwie zasadnicze wady:\n\n\n  Wspomniana już obsługa wyjątków w której musimy pamiętać z jakiego mechanizmu skorzystać. Blok try-catch dla kody synchronicznego i catchError dla asynchronicznego. Jest to rozwiązanie podatne na błędy programisty.\n  Trudny w śledzeniu kod. Chcąc prześledzić kolejność wykonania funkcji należy się dodatkowo skupić na wszystkich obiektach future i ich własnym łańcuchu wywołań then.\n\n\nA co gdyby istniał mechanizm, który rozwiązuje oba te problemy? Możliwość czytania dowolnego kodu od góry do dołu, bez znaczenia czy jest synchroniczny, czy asynchroniczny. Łapania błędów w ustandaryzowany sposób nawet gdy jest uruchamiany przez Event Loop. To nie mrzonka, a najprawdziwszy fakt. Dart dostarcza programiście dwa krótkie słowa kluczowe, które sprawiają, że kod zawsze wygląda jakby był przetwarzany synchronicznie.\n\nTa dodatkowa składnia to async i await. Nie dają one co prawda nowych możliwości w kontekście funkcjonalnym, a jedynie wprowadzają cukier składniowy (syntatic sugar), aby kod był czytelniejszy i bardziej utrzymywalny.\n\nasync\n\nSłowo kluczowe async służy do oznaczenia funkcji jako asynchronicznej. Użycie go niesie za sobą następujące implikacje:\n\n\n  Typ zwracany przez funkcję automatycznie staje się Future&amp;lt;T&amp;gt;. Nawet w najprostszym scenariuszu jak ten:\n\n\nint getOne() async =&amp;gt; 1;\n\n\nUruchomienie takiej funkcji zakończy się błędem, bo zwrócony typ to nie int, a Future&amp;lt;int&amp;gt;. Poprawny kod:\n\nFuture&amp;lt;int&amp;gt; getOne() async =&amp;gt; 1;\n\n\n\n  W obrębie funkcji dozwolne jest używanie słowa kluczowego await. Bez async nie ma await. Jak yin i yang.\n\n\nawait\n\nZadaklarowałeś funkcję jako asynchroniczną i co dalej? Masz teraz pełne prawo do potraktowania dowolnego obiektu future składnią await. W gruncie rzeczy jest to taki then na sterydach.\n\nimport &#39;dart:async&#39;;\n\nFuture&amp;lt;void&amp;gt; main() async {\n  print(&quot;1&quot;);\n\n  try {\n    await Future(() {\n      print(&quot;2&quot;);\n      int.parse(&quot;future&quot;);\n    });\n  } catch (_) {\n    print(&quot;3&quot;);\n  }\n\n  print(&quot;4&quot;);\n}\n\n\n1\n2\n3\n4\n\n\nKod czytany od góry do dołu, łapiący asynchroniczny wyjątek i nie wymagający żadnego skupienia żeby poprawnie wskazać jaka będzie kolejność printowania. O to właśnie chodziło. await nakazuje aby poczekać na pełne wykonanie kodu asynchronicznego i dopiero gdy się on zakończy przejdzie dalej.\n\nNie jest to jednak jakby się mogło wydawać instrukcja blokująca nasz jedyny wątek. Napotykając na await następuje zwolnienie wykonania i przekazanie kontroli do Event Loop. Analogicznie jak dla then, bo w praktyce on tutaj jest, a jedynie ukrywa się za ładniejszą składnią.\n\nZachłanny microtask\n\nBardziej jako ciekawostka, niż coś co przydaje się w codziennym pisaniu aplikacji jest zachłanność kolejek. A raczej kolejki, która ma wyższy priorytet - Microtask Queue.\n\nimport &#39;dart:async&#39;;\n\nvoid attentionPlease() {\n  scheduleMicrotask(() =&amp;gt; attentionPlease());\n}\n\nvoid main() {\n  print(&quot;start main&quot;);\n  Future(() =&amp;gt; print(&quot;future is now&quot;));\n\n  scheduleMicrotask(() =&amp;gt; print(&quot;micro1&quot;));\n  attentionPlease();\n  scheduleMicrotask(() =&amp;gt; print(&quot;micro2&quot;));\n\n  print(&quot;end main&quot;);\n}\n\n\nstart main\nend main\nmicro1\nmicro2\n???\n\n\nGdzie się podział future is now? Czeka na swoją kolej aż wyższa kolejka się opróżni. Nie nastąpi to jednak nigdy bo gdy tylko kończy się jedno zadanie, dodawane jest kolejne i tak w nieskończoność.\n\n\n  Wypisz start main\n  Dodaj future do kolejki\n  Dodaj microtask micro1 do kolejki\n  Uruchom funkcję która doda nowy microtask do kolejki\n  Dodaj microtask micro2 do kolejki\n  Wypisz end main\n  Uruchom microtask: micro1\n  Uruchom microtask, który dodaje do kolejki następny microtask\n  Uruchom microtask: micro2\n  Uruchom microtask, który dodaje do kolejki następny microtask\n  Uruchom microtask, który dodaje do kolejki następny microtask\n  Uruchom microtask, który dodaje do kolejki następny microtask\n\n\n… i tak w nieskończoność dopóki ręcznie nie zamkniemy programu. Future najzwyczajniej w świecie nie ma szansy zostać podjętym przez Event Loop. Zapomniany na wieki. Problem można łatwo rozwiązać poprzez … nieużywanie scheduleMicrotask jeśli nie jest to całkowicie niezbędne.\n\nPodsumowanie\n\nDart pomimo tego, że jest jednowątkowy to radzi sobie świetnie z przetwarzaniem instrukcji i zachowaniem responsywności swojego jedynego wątku. Zadania nie wymagające czasu pracy procesora jak ruch sieciowy, czy operacje na plikach wykonują się z boku i tylko w odpowiednim momencie dorzucają nowe zdarzenia do Event Loop. Kieruje on i decyduje o tym co ma się teraz wykonać z uwzględnieniem dwóch podległych kolejek. Pisz kod z wykorzystaniem async/await, aby ograniczyć ryzyko błędów i ułatwić sobie powrót do takiego kodu za jakiś czas. To na prawdę działa.\n\nJest to pierwszy wpis z serii dotyczącej przetwarzanie instrukcji w aplikacjach Flutterowych. W najbliższym czasie spodziewaj się kontynuacji, która zachwieje faktem wykonywania tylko jednej instrukcji w danym czasie, nawet pomimo wspomnianej już kika razy jednowątkowości. Do następnego!\n"
} ,
  
  {
    "title"    : "HookWidget, czyli Flutterowe hooki",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-hooks/",
    "date"     : "May 8, 2020",
    "excerpt"  : "Czym właściwie są hooki? Jest to termin dobrze znany wszystkim programistom m.in. Reacta, gdzie hooki jakiś czas temu opanowały cały ekosystem i wybuchł na nie ogromny hype. Powstały przede wszystkim po to, aby ułatwić współdzielenie logiki między...",
  "content"  : "Czym właściwie są hooki? Jest to termin dobrze znany wszystkim programistom m.in. Reacta, gdzie hooki jakiś czas temu opanowały cały ekosystem i wybuchł na nie ogromny hype. Powstały przede wszystkim po to, aby ułatwić współdzielenie logiki między stanowymi komponentami widgetami (takimi jak StatefulWidget) oraz uprościć logikę, która stoi za tzw. life-cycle methods, czyli co powinno się wydarzyć przed pierwszym renderowaniem, przy kolejnych, jak reagować na zmiany parametrów renderowania itd. Generalnie wszystko sprowadza się do tego jak zebrać cały ten bałagan i zrobić go czytelniejszym.\n\nCzy się udało? W Reacie jak najbardziej! Większość developerów już przeszła na nowe rozwiązanie, które z własnego doświadczenia również szczerze polecam. A co z Flutterem? No bo przecież dobrze wiemy, że styl pisania aplikacji jest mocno podobny (deklaratywny), więc może hooki są też dla nas? Przyznaj szczerze, że w głębi serca to jednak nie przepadasz za wbudowanym StatefulWidgetem i chętnie byś go wymienił na inne rozwiązanie, tylko jakie?\n\n\n  Flutterowcy żądają hooków!\n\n\n\n\nFlutter Hooks\n\nNie musisz sam rozmyślać o tym jak zaimplementować cały koncept hooków we Flutterze. Ktoś już to zrobił za nas. A w sumie to nie ktoś, a Remi Rousselet tworzący na prawdę mocne paczki w ekosystemie, takie jak chociażby opisywany już Provider. Dzięki Remi!\n\nPaczkę znajdziesz na pub.dev, a instalacja sprowadza się do dodania pojedynczego wpisu w pubspec.yaml i gotowe. Można zacząć korzystać i rzucić StatefulWidget w kąt. Tylko co tak na prawdę możemy zrobić z tą paczką? Jakie hooki dostarcza i w jakich sytuacjach ich używać? No i rzecz jasna najważniejsze pytanie …\n\n\n  A po co to komu? A na co to komu potrzebne?\n\n\nZłota zasada\n\nZanim przejdziemy do praktycznego zastosowania, omówmy złotą zasadę korzystania z hooków. Brzmi ona następująco: “Każdy build widgeta musi zawołać te same hooki w tej samej kolejności”. Nie ma wyjątków od tej reguły, koniec kropka. Oznacza to, że nie wołasz hooków w obrębie if/else, ani nie kończysz wywołania builda przed odpalaniem ostatniego ze swoich hooków. Najprościej będzie jeśli zawsze na początku metody build uruchomisz wszystkie hooki, a dopiero w dalszej części przejdziesz do wykorzystania ich wartości i rysowania drzewa na ekranie.\n\nNIE dla if-ów:\n\nWidget build(BuildContext context) {\n  if (something) {\n    useSomeHook();\n  }\n}\n\n\nNIE dla hooków uruchamianych po warunkowym wyjściu z builda:\n\nWidget build(BuildContext context) {\n  if (something) {\n    return Text(&quot;Loading&quot;);\n  }\n\n  final data = useSomeHook();\n}\n\n\nTAK dla hooków na starcie, a potem rób co chcesz:\n\nWidget build(BuildContext context) {\n  final data = useSomeHook();\n  useSomeOtherHook();\n  useEvenMoreHooks();\n\n  if (something) {\n    return Text(&quot;Loading&quot;);\n  }\n\n  return Text(&quot;My super app&quot;)\n}\n\n\nCo jak jednak nie posłuchasz? To co zwykle dzieje się w takich przypadkach, czekają Cię błędy na poziomie uruchomieniowym (runtime). A przecież nikt nie lubi błędów - ani Ty, ani użytkownik Twojej wypieszczonej aplikacji. To co, gotowy?\n\nuseState\n\nJeden z najczęściej używanych przez mnie hooków, a na dodatek świetnie nadający się do celów demonstracyjnych. useState to nic innego jak mechanizm zarządzania lokalnym stanem w obrębie pojedynczego widgeta. Brzmi znajomo? To właśnie główny feature od StatefulWidgeta zamknięty w ramach jednej funkcji.\n\n\n\nSpójrzmy jak wygląda domyślna aplikacja wygenerowana po flutter create. Pamiętasz ją? Jedno-przyciskowy ekran zliczający kliknięcia.\n\n\n\nStatefulWidget\n\nW wersji standardowej mamy dwie powiązane ze sobą klasy (widget i state), użycie setState i to w gruncie rzeczy tyle.\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key}) : super(key: key);\n\n  @override\n  _MyHomePageState createState() =&amp;gt; _MyHomePageState();\n}\n\nclass _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(\n              &#39;You have pushed the button this many times:&#39;,\n            ),\n            Text(\n              &#39;$_counter&#39;,\n              style: Theme.of(context).textTheme.display1,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\nHookWidget\n\nOsiągnięcie tego samego efektu przy pomocy hooków ogranicza się do użycia jednej klasy:\n\nclass MyHomePage extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final counter = useState(0);\n\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(\n              &#39;You have pushed the button this many times:&#39;,\n            ),\n            Text(\n              &#39;${counter.value}&#39;,\n              style: Theme.of(context).textTheme.display1,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () =&amp;gt; counter.value++,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n\n\nRóżnica polega na tym, że zamiast dwóch klas mamy teraz tylko jedną, dziedziczącą po HookWidget. Pamiętaj o tym, bo tylko w takim widgecie możesz używać hooków! Mamy także wywołanie useState(0), który tworzy lokalny stan przechowujący liczbę kliknięć (zaczynając od zera). Zwracany obiekt jest typu ValueNotifier&amp;lt;int&amp;gt;, stąd jego odczyt i zapis nie odywa się bezpośrednio przez counter, tylko przez counter.value (wartość docelowa). Każda zmiana stanu prowadzi do przebudowania widgeta, zupełnie jak to ma miejsce przy domyślnym setState.\n\nNa pierwszy rzut oka mogłoby się wydawać, że każde przebudowanie będzie prowadziło do zresetowania licznika. No bo jak to? Przecież ta konkretna linijka jest odpalana za każdym razem gdy rysujemy nasz widget. Masz rację, jest odpalana za każdym razem, ale stan jest automatycznie pamiętany jak to ma miejsce w StatefulWidget. Magia hooków, a tak na prawdę to polecam spojrzeć do kodu źródłowego useState. Dosłownie kilka linii kodu które wszystko tłumaczą.\n\nSkoro oba rozwiązania działają tak samo to po co przepłacać? Ja tu widzę osobiście benefity na rzecz HookWidgeta:\n\n\n  Jedna klasa zamiast dwóch zaspokaja potrzebę minimalizmu i dobrego smaku\n  Mniej kodu to mniej kłopotów\n  Dodanie stanowości do bezstanowego widgeta ogranicza się do zmiany extends StatelessWidget na extends HookWidget (git ma mniejszego diffa)\n  Możliwość użycia pozostałych hooków skoro jesteśmy już w HookWidget\n\n\n\n\nCiekawą alternatywą dla useState jest useValueNotifier, który działa na identycznej zasadzie, ale nie przebudowuje widgeta przy zmianie wartości. Nie raz zdarza się, że chcemy trzymać pewną wartość i zmieniać ją w widgecie, ale nie wpływa to nijak na to co prezentujemy użytkownikowi. A skoro nie widać różnicy, to unikajmy zbędnego przerysowywania.\n\nUżyłem go tyle razy, że jestem w stanie zliczyć wystąpienia na palcach jednej ręki, ale zawsze warto pamiętać że mimo wszystko istnieje i czeka na swój czas.\n\nuseMemoized\n\nMamy ograne zarządzanie stanem, ale to przecież nie wszystko co potrafi StatefulWidget! Co więcej, często używamy odmiany stanowej nawet jeśli żadnego stanu nie potrzebujemy. Wszystko za sprawą potrzeby uruchomienia pewnego kodu tylko raz per widget, który przeprowadzi wstępną inicjalizację, a kolejne buildy będą czerpać z uprzedniego wyniku. Mowa o zbawiennym initState, który wywołany zostanie tylko raz i umożliwia nam chociażby wysłanie zapytania do API, a następnie korzystanie z zapisanej odpowiedzi przy każdym re-buildzie. Chyba nie chciałbyś bombardować własnego API na każdym renderze? Dobrze, bo ja też nie.\n\nWersja standardowa w której tylko raz wysyłamy request i wyświetlamy jego odpowiedź w najprostszej możliwej wersji wyglądałaby jak poniżej. Zwróć uwagę że nie parsujemy odpowiedzi do JSONa, ani nie robimy innych zbędnych cyrków. Rysujemy prymitywnego stringa, upraszczamy jak się da.\n\n\n\nStatefulWidget\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key}) : super(key: key);\n\n  @override\n  _MyHomePageState createState() =&amp;gt; _MyHomePageState();\n}\n\nclass _MyHomePageState extends State&amp;lt;MyHomePage&amp;gt; {\n  String data;\n\n  @override\n  void initState() {\n    initStateAsync();\n    super.initState();\n  }\n\n  Future&amp;lt;void&amp;gt; initStateAsync() async {\n    final response = await http.get(&#39;https://jsonplaceholder.typicode.com/albums/1&#39;);\n\n    setState(() {\n      data = response.body;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Text(data),\n      ),\n    );\n  }\n}\n\n\nHookWidget\n\nWersja zahookowana, w której korzystamy z useMemoized. Zostanie on wywołany tylko przy pierwszym buildzie, zupełnie jak wspomniany wyżej initState.\n\nclass MyHomePageHook extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final data = useState(&quot;&quot;);\n    useMemoized(() async {\n      final response = await http.get(&#39;https://jsonplaceholder.typicode.com/albums/1&#39;);\n\n      data.value = response.body;\n    });\n\n    return Scaffold(\n      body: Center(\n        child: Text(data.value),\n      ),\n    );\n  }\n}\n\n\nZnowu mniej kodu, co? Ja już od dawna jestem sprzedany temu rozwiązaniu, ale pamiętam, że chwilę zajęło mi pogodzenie się z tym nowym formatem. W domyślnym zapisie mam przecież dedykowaną metodę initState w której przeprowadzam wszystkie te specyficzne operacje, a tu nagle mam je robić w buildzie? Brzmi nieswojo, ale na prawdę warto! Po pewnym czasie staje się to zupełnie naturalne i oczywiste.\n\nZ tym stwierdzeniem, że useMemoized jest uruchamiany tylko raz to tak nie do końca prawda. W sensie w naszym przykładzie jak najbardziej i jeśli będziemy tak go używali to rzeczywiście osiągnięmy wspomnianą jednorazowość. Możemy jednak osiągnąć znacznie więcej!\n\nKlucz do sterowania hookiem\n\nuseMemoized przyjmuje argument keys, który mimo swojej prostoty, otwiera ogrom możliwości (bo jest kluczem!). Koncept polega na tym, że jest to opcjonalna lista obiektów, którą przekazujemy do hooka. Stanie się ona jego identyfikacją, tożsamością. Oznacza to, że jakakolwiek zmiana w tej liście doprowadzi do ponownego uruchomienie hooka przy kolejnym buildzie. Taki system cache-owania. Tak długo jak klucze są identyczne bierz wartość z cache, w przeciwnku wypadku przelicz nową wartość i zapisz ją na przyszłość. Najlepiej będzie jak zobaczymy to w akcji rozbudowując poprzedni przykład. Dodajmy przycisk do zmiany albumu na kolejny. Internaktywność, yay!\n\nclass MyHomePageHook extends HookWidget {\n  @override\n  Widget build(BuildContext context) {\n    final albumId = useState(1);\n    final data = useState(&quot;&quot;);\n    useMemoized(() async {\n      final response = await http\n          .get(&#39;https://jsonplaceholder.typicode.com/albums/${albumId.value}&#39;);\n\n      data.value = response.body;\n    });\n\n    return Scaffold(\n      body: Center(\n        child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [\n          Text(\n            &quot;Album ID: ${albumId.value}&quot;,\n            style: TextStyle(color: Colors.red),\n          ),\n          Text(data.value),\n          RaisedButton(\n            child: Text(&quot;Bump&quot;),\n            onPressed: () =&amp;gt; albumId.value++,\n          )\n        ]),\n      ),\n    );\n  }\n}\n\n\nJak zadziałała aplikacja? Połowicznie:\n\n\n\nCo prawda albumId się ładnie aktualizuje po każdym kliknięciu, ale wyświetlane dane już nie za bardzo. Co można z tym zrobić? Dodać klucze!\n\nuseMemoized(() async {\n  final response = await http\n      .get(&#39;https://jsonplaceholder.typicode.com/albums/${albumId.value}&#39;);\n\n  data.value = response.body;\n}, [albumId.value]);\n\n\nTym właśnie sposobem powiedzieliśmy useMemoized że ma wywołać swoją wewnętrzną funkcję za każdym razem gdy zmieni się wartość trzymana w albumId.value. Na pierwszy rzut oka cały ten flow jest nieintuicyjny, jednak nic mylnego! To świetnie zaprojektowana machineria do często powtarzających się problemów. Wystarczy delikatnie wysterować swoje rozumowanie na boczny tor i zacząć cieszyć się z prostego i zwięzłego zapisu.\n\n\n\nW liście możesz oczywiście umieścić tyle elementów ile tylko pragniesz. Zmiana któregokolwiek z nich doprowadzi do ponownego odpalenia funkcji w useMemoized, ale z praktycznego punktu widzenia będzie to najczęściej jeden obiekt, góra dwa.\n\nuseEffect\n\nOstatni z wielkiej trójcy hooków, których używa się najczęściej przy tworzeniu aplikacji. Swoim działaniem jest nieco zbliżony do useMemoized, ale nie daj się zwieść pozorom - wykorzystasz go w innych okolicznościach i przypadkach.\n\nGłówne podobieństwo do useMemoized polega na tym, że tutaj również dostarczamy opcjonalną listę kluczy do identyfikacji, których zmiana powoduje ponowne uruchomienie wewnętrznej funkcji. A różnica? Praktycznie to są dwie:\n\n\n  useEffect nie zwraca żadnej wartości, nie trudź się więc z przypisaniem jego wyniku do zmiennej\n  Funkcja uruchamiana przez useEffect musi zwrócić funkcję (callback) do ewentualnego posprzątania po sobie\n\n\nPierwsza różnica jest prosta. useMemoized zwróci nam wynik swojej funkcji, useEffect nie. W porządku, a co z tym drugim wymaganiem? Funkcja musi zwrócić funkcję. Dlaczego? Bo taki właśnie jest zamysł stojący za efektami - mogą brudzić, czyli np. otwierać połączenia sieciowe, nasłuchiwać na strumieniach, czy też innych podobnych strukturach i jako dobry developer powinieneś te rzeczy sprzątnąć, zupełnie tak jak robisz to w przypadku metody dispose na StatefulWidget.\n\nKiedy zatem używać useEffect? Zawsze wtedy gdy musiałbyś użyć initState połączonego z dispose. Jeśli potrzebujesz takiego useMemoized, ale funkcja którą w nim uruchamiasz stackuje pewien problem - np. każde wywołanie dodaje kolejnego listenera - to useEffect jest stworzony do rozwiązania tego problemu.\n\nHooki\n\nPrzedstawione hooki to oczywiście dopiero czubek góry lodowej i nawet samych wbudowanych jest o wiele więcej. Bardzo przydatne okazują się useAnimationController do przeprowadzania animacji, usePrevious do uzyskania wartości obiektu z poprzedniego builda, czy chociażby useFuture zastępujący całkowicie FutureBuildera. Jeśli chciałbyś zobaczyć co jeszcze oferują hooki to nie ma lepszego miejsca niż oficjalna dokumentacja.\n\nNa koniec pamiętaj o ważnej rzeczy, która nie została wcześniej poruszona. Jeśli potrzebujesz nietypowego hooka, to bez problemu możesz go sam napisać bazując na innym już istniejącym. W swoich projektach mam kilka dodatkowych hooków, które często za mną podążają jak np. useTabController.\n\nKod pełnej aplikacji znajdziesz na https://github.com/vintage/flutter_demo_hooks.\n"
} ,
  
  {
    "title"    : "Nawigowanie między ekranami - Navigator",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-navigation/",
    "date"     : "November 30, 2019",
    "excerpt"  : "Myśląc o aplikacji mobilnej wyobrażasz sobie najprawdopodobniej kafelek na wyświetlaczu telefonu, który możesz stuknąć w celu uruchomienia programu na pełnym ekranie. W zależności od szybkości urządzenia już po chwili widzisz to czego się spodziew...",
  "content"  : "Myśląc o aplikacji mobilnej wyobrażasz sobie najprawdopodobniej kafelek na wyświetlaczu telefonu, który możesz stuknąć w celu uruchomienia programu na pełnym ekranie. W zależności od szybkości urządzenia już po chwili widzisz to czego się spodziewasz, czyli aplikację. A właściwie to jej ekran startowy (początkowy).\n\nEkran startowy. Tak właśnie nazwiemy pierwszy widok, który jest nam prezentowany tuż po uruchomieniu się aplikacji. I tak dla Twittera będzie to ściana z tweetami, w Messengerze lista kontaktów z którymi ostatnio korespondowaliśmy, a w Uberze panel do zamówienia podwózki. Oczywista oczywistość.\n\n\n  Oni to wiedzą Kocie.\n\n\nCo jednak zrobisz, gdy powiem Ci, że aplikacja składa się z reguły z wielu ekranów, a ten startowy to dopiero początek? Że możesz przechodzić do różnych miejsc przy użyciu przycisków, menu, czy gestów? Weźmy takiego Messengera. Możesz wejść w szczegóły konwersacji, aby ją odczytać, czy napisać nową wiadomość do rozmówcy, a nawet przejść do ekranu z relacjami swoich znajomych.\n\n\n  …\n\n\nWzruszysz ramionami, lub weźmiesz mnie za durnia, bo przecież KAŻDA aplikacja udostępnia możliwość nawigowania między różnymi sekcjami i nie trzeba o tym pisać wstępu. Dobrze się składa, przejdźmy do działania!\n\n\n\nNavigator\n\nSkoro nawigacja między ekranami jest tak kluczowa dla każdej aplikacji mobilnej, to czy Flutter ułatwia developerem zmierzenie się z tym problemem? Czy może potrzebujemy doinstalować zewnętrzną zależność, która ogra za nas wszelkie trudy? Zamknij pubspec.yaml, nie potrzebujemy niczego ponad sam framework, który z pudełka dostarcza widget (a jakże) Navigator upraszający cały proces do granic możliwości.\n\nCzym tak właściwie jest Navigator? Najprościej mówiąc, jest to widget, który wewnątrz siebie zarządza listą dzieci (widgetów) w formie tzw. stosu oraz udostępnia spójny interfejs do wkładania i zdejmowania elementów właśnie poprzez stos. A ten cały stos? To popularna struktura danych (spokojnie!) polegająca na tym, że zaczynamy z “pustym stołem” na który wykładamy (push) karty w sposób jedna na drugą, przykrywając je w całości. Gdy stos będzie zawierał kilka kart, jako jego użytkownik mamy dostęp tylko do karty na samym wierzchu. W przypadku gdy chcemy dostać się głębiej - musimy najpierw zrzucić (pop) karty powyżej. Ot i cała filozofia stosu.\n\n\n\n\n  Screen 1 jest na samym dole stosu, a Screen 4 na samej górze co gwarantuje mu to, że jest aktualnie widocznym ekranem. Wkładając nowy ekran znajdzie się on na górze stosu, a jeśli chcielibyśmy ponownie wyświetlić Screen 1 to musimy najpierw pozrzucać w nicość ekrany ponad nim (zaczynając od samej góry).\n\n\nStos w Navigatorze różni się od przedstawionego opisu wyłącznie tym, że zamiast kart operujemy ekranami. Wkładamy je i zdejmujemy, zawsze widząc wyłącznie ekran, który znajduje się na samej górze stosu. Ten wrzucony na niego jako ostatni.\n\nDemistyfikację Navigatora i sposobu jego działania możemy uznać za zakończoną. Wiesz już w teorii jak działa i jesteś gotowy na mięcho - praktyczne użycie w aplikacji, które udowodni, że temat nie jest tak płytki jak może się to teraz wydawać.\n\nPortal\n\nZacznijmy od początku, czyli od ekranu startowego. Stworzymy w tym celu aplikację o roboczej nazwie Portal, którą będziemy rozwijać przez dalszą część wpisu o dodatkowe mechaniki i sposoby nawigowania.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nvoid main() {\n  runApp(MaterialApp(\n    home: RouteOne(),\n  ));\n}\n\nclass RouteOne extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Text(&quot;Navigator Demo&quot;),\n            RaisedButton(\n              child: Text(&quot;Push&quot;),\n              onPressed: () {},\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n\nPamiętasz jak wspominałem o “pustym stole” stosu na starcie? To nie do końca prawda w projekcie pisanym we Flutterze. Użytkownik uruchamiający aplikację widzi przecież ekran z tekstem i przyciskiem, a nie czarną dziurę. Stos nie jest więc wcale pusty! Magia? Technologia! Parametr home przekazany do MaterialApp wkłada wskazany widget na stos przy starcie, tak by zainicjalizować ekran początkowy. Wygodne, bo po co robić to ręcznie, prawda?\n\nPo uruchomieniu aplikacji powinienieś zobaczyć poniższy widok. Przycisk rzecz jasna nie działa - nie zaprogramowaliśmy co dokładnie ma się wydarzyć po kliknięciu. A skoro tego nie zrobiliśmy to przycisk robi absolutne NIC.\n\n\n\nNaprzód (push)\n\nPodstawową operacją w nawigowaniu jest wepchnięcie nowego ekranu na stos, a nie jego zdjęcie. Dlaczego? Bo żeby coś zrzucić ze stosu, trzeba najpierw to na niego dodać. Prosta logika w moim wykonaniu jest prosta. Co więc uczynimy w tym momencie? Wepchniemy nowy ekran na stos! A ekran to nic innego jak dowolny widget, a skoro dowolny - to nie musimy nawet tworzyć dla niego osobnej klasy. Wepchniemy na stos bezpośrednio zlepek widgetów - tak aby udowodnić że można tam wrzucić dosłownie cokolwiek.\n\nRaisedButton(\n  child: Text(&quot;Push&quot;),\n  onPressed: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) =&amp;gt; Center(\n          child: RaisedButton(\n            child: Text(&quot;Pop&quot;),\n            onPressed: () {},\n          ),\n        ),\n      ),\n    );\n  },\n)\n\n\nImplementacja wygląda dość oczywiście. Wywołujemy funkcję Navigator.push, której zadaniem jak nazwa sugeruje jest wrzucenie nowego ekranu na stos (czyli jego wyświetlenie). Pierwszym parametr to context, który jest przekazywany do metody build naszego widgeta, drugi natomiast wydaje się bardziej interesujący i mniej zrozumiały. Mieliśmy przecież wrzucić widget, a wcale tak to nie wygląda.\n\nCzyżbym znowu nie powedział całej prawdy o nawigacji? Masz mnie. Navigator zawiera stos ekranów, jednak ekranem jest obiekt typu PageRoute, a nie bezpośrednio nasz widget docelowy. Oficjalnie przyjęte nazewnictwo jest takie, że na stosie znajdują się routes (ścieżki?), jednak można śmiało zamiennie używać słowa ekran, czy też strona, które są bardziej adekwatne w naszym ojczystym języku.\n\nSkoro “oszustwo” ze ścieżkami zostało wyjaśnione to co tu się właściwie dzieje? Tworzymy nową instancję widgeta MaterialPageRoute, który działa na zasadzie tzw. buildera. Nie otrzymuje on jak to zwykle bywa parametru child, lecz funkcję builder, która dynamicznie buduje niezbędne drzewo w odpowiednim momencie (gdy zachodzi proces nawigacji). Zadaniem funkcji jest de facto zwrócenie pełnego drzewa widgetów na nowym ekranie, który za moment zostanie wyświetlony użytkownikowi.\n\nSam w sobie MaterialPageRoute dostarcza jeszcze jedną ważną składową do naszej aplikacji - animację. Ekran nie jest chamsko podmieniany na nowy jak w maszynie stanowej, zamiast tego dostajemy ładną animację przejścia, która dostosowuje się do aktualnej platformy, aby jak najlepiej odwzorować natywne niuanse. Możesz rzecz jasna napisać własną animację przejścia poprzez rozszerzenie bazowego PageRoute i cieszyć się w pełni dostosowanym doznaniem, lub ewentualnie skorzystać z wbudowanego CupertinoPageRoute, który wymusi animację typu iOS na wszystkich dostępnych platformach. Wybór należy do Ciebie, jedyne co trzeba zrobić to podmienić wywołanie MaterialPageRoute na własną klasę.\n\n\n\n\n  Animacja Material w stylu Android\n\n\n\n\n\n  Animacja Cupertino w stylu iOS\n\n\nWidget per ekran\n\nMimo tego, że podczas nawigacji możemy wepchnąć dowolne drzewo z widgetami jako nowy ekran to dobra praktyka mówi - nie rób tego. Serio. Zamiast tego stwórz pachnący nowością widget (klasę) i w nim umieśc to co dokładnie chcesz narysować. Tak nakazuje przyzwoitość. Dlaczego? Żeby kod był łatwiej utrzymywalny i czytelniejszy, ale również dlatego, że nigdy nie wiesz z jakiego miejsca w aplikacji będzie można się dostać do danego ekranu w przyszłości. Dzisiaj jest to prosty przycisk, jutro zarząd chciałby dodatkowe menu po lewej stronie, a za miesiąc użytkownik będzie smagał palcem po ekranie rysując odpowiednie gesty nawigacyjne, które zaprowadzą go również do ekranu docelowego.\n\n\n  Stosuj się do zasady “Nowy ekran, nowy widget”, a będziesz szczęśliwszym programistom. Zaufaj mi i całej społeczności Flutterowej.\n\n\nWierzę, że dałeś się przekonać do dobrego i jesteś gotowy na drobny refaktoring w kodzie. Stworzymy odseparowany widget na nasz drugi ekran, tak by był łatwo dostępny z dowolnego miejsca w kodzie:\n\nclass RouteTwo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: RaisedButton(\n          child: Text(&quot;Pop&quot;),\n          onPressed: () {},\n        ),\n      ),\n    );\n  }\n}\n\n\nI oczywiście użyjmy RouteTwo zamiast bezpośredniego drzewa podczas przejścia między ekranami:\n\nRaisedButton(\n  child: Text(&quot;Push&quot;),\n  onPressed: () {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (context) =&amp;gt; RouteTwo(),\n      ),\n    );\n  },\n)\n\n\nWstecz (natywnie)\n\nPołowa operacji na stosie za nami. Wpychamy na niego nowy ekran, więc umiemy chodzić do przodu. W niektórych aplikacjach może to nawet wystarczyć. Użytkownik nawiguje przed siebie i nie jest zainteresowany tym co już było, lub nawet gdy jest - nie dajemy mu szansy powrotu.\n\nCzy aby jednak na pewno nie możemy się w aktualnej wersji cofnąć do ekranu startowego? Przycisk Pop  nie jest w stanie nam pomóc, bo nie został oprogramowany. Musimy jednak pamiętać o systemie operacyjnym uruchamiającym program, który sam z siebie dostarcza mechanizm cofania. Nawet w sytuacji gdy programista sam nie uwzględni takiej możliwości. Dziękuję panie System Operacyjny za zrobienie tego za mnie!\n\nMowa oczywiście o przycisku cofania w Androidzie, zarówno tym sprzętowym jak i wirtualnym. Użytkownik zawsze ma możliwość wduszenia strzałki wstecz, która zrzuci aktualny ekran ze stosu i cofnie użytkownika do poprzedniego ekranu, lub jeśli takowego nie ma - zaprezentuje pulpit urządzenia, który jest poza naszą kontrolą. Podobnie sytuacja wygląda na iOS, gdzie cofamy się przy użyciu gestu pociągnięcia za ekran od lewej do prawej.\n\n\n  Pamiętaj o tym i trzymaj zawsze z tyłu głowy, że nawet gdy nie udostępnisz przycisku cofnięcia to system zrobi to za Ciebie. Zupełnie jak przeglądarka internetowa która również posiada przyciski do nawigowania, bez znaczenia jaką stronę aktualne wyświetla.\n\n\nWstecz (pop)\n\nNie jesteśmy jednak zdani wyłącznie na cofanie z poziomu systemu. Tworząc interfejs przyjazny użytkownikowi trafimy w końcu na sytuację w której chcemy dać możliwość cofnięcia się przy użyciu własnej kontrolki, lub programowo np. ekran czasowy, ktory dostępny jest tylko przez 5 sekund po których następuje cofnięcie (ponosi mnie fantazja).\n\nCzy tak się da? Nie może by inaczej, wszystko pod programistyczną kontrolą! Nawet sama operacja jest łatwiejsza niż wrzucanie nowego ekranu, bo nie musimy mówić co zrzucamy. Mówimy po prostu - zrzuć ten ekran, zapomnij o nim na wieki.\n\nZaaplikuj poniższy kod na klasie RouteTwo, aby możliwa była pełna nawigacja przy użyciu elementów wewnątrz aplikacji.\n\nRaisedButton(\n  child: Text(&quot;Pop&quot;),\n  onPressed: () {\n    Navigator.pop(context);\n  },\n)\n\n\nTrudno cokolwiek tutaj objaśniać. Wywołujemy funkcję Navigator.pop z aktualnym kontekstem i gotowe. Ekran zostaje zrzucony, uruchamia się animacja, lądujemy na ekranie poprzedzającym. Łatwiej się nie da.\n\nŚcieżki nazwane\n\nWiększe aplikacje zawierające dużą liczbę ekranów rządzą się swoimi prawami. O ile przedstawione sposoby nawigacji są uniwersalne i zadziałają w aplikacji o dowolnej złożoności, to często rezygnuje się ze standardowego Navigator.push na rzecz Navigator.pushNamed. Wynik działania obu tych funkcji jest identyczny - użytkownik trafia na nowy ekran - różni się jedynie sposób wywołania. Pierwsza funkcja wymaga manualnego utworzenia PageRoute wraz z powiązanym widgetem za każdym razem gdy chcemy przeprowadzić nawigację. Druga natomiast potrzebuje wyłącznie nazwy ścieżki do której chcemy przekierować użytkownika.\n\nSpójrz na oba wywołania i sam zdecyduj które jest przyjemniejsze w utrzymywaniu:\n\nvar option1 = Navigator.push(\n  context, MaterialPageRoute(\n    builder: (context) =&amp;gt; RouteTwo(),\n  )\n);\n\nvar option2 = Navigator.pushNamed(context, &quot;/route-two&quot;);\n\n\n\n  Złota zasada programowania: “Im mniej kodu tym lepiej”\n\n\nZalety push:\n\n  Istnieje\n  Nieznacznie łatwiej przekazywać dane podczas nawigowania\n\n\nZalety pushNamed:\n\n  Mniej kodu\n  Brak bezpośredniej zależności (importy) między różnymi widgetami\n  Mniej kodu × każde wywołanie nawigacji\n  Również istnieje\n\n\nJeśli więc pushNamed jest tak dobry i bezkonkurencyjny to wymieńmy przycisk z pierwszego ekranu, aby skorzystał z wymienionych dobrodziejstw.\n\nRaisedButton(\n  child: Text(&quot;Push&quot;),\n  onPressed: () {\n    Navigator.pushNamed(context, &quot;/route-two&quot;);\n  },\n)\n\n\nVoilà! Przycisk przestał teraz całkowicie działać i nie wykonuje po stuknięciu żadnej akcji. Co do #####? Czyli że niby zapis jest krótszy i w ogóle, ale nie robi tego co powinien? Daj mi chwilę a wszystko wytłumaczę, momencik. Z grubsza chodzi o to, że nawigujemy do ścieżki /route-two, ale skąd Flutter ma wiedzieć gdzie to jest? Potrzebujemy skonfigurować drogowskazy do ścieżek dostępnych w obrębie aplikacji.\n\n\n\nCo z tymi drogowskazami? Jak powiedzieć aplikacji, że pod daną ścieżką znajduje się dany widget? Nic prostszego! Wszystkie obsługiwane ścieżki aplikacji należy zdefiniować na poziomie MaterialApp poprzez parametr routes.\n\nrunApp(MaterialApp(\n  home: RouteOne(),\n  routes: {\n    &quot;/route-two&quot;: (context) =&amp;gt; RouteTwo(),\n  }\n));\n\n\nKażdy ekran aplikacji musi zostać zadeklarowany właśnie w obrębie routes. Jedynym wyjątkiem jest ekran startowy, który bez naszego udziału rejestruje się pod adresem /. Jeśli sam spróbujesz go zarejestrować otrzymasz błąd kompilacji, mówiący o tym, że operacja nie ma sensu, bo framework robi to za Ciebie.\n\nrunApp(MaterialApp(\n  home: RouteOne(),\n  routes: {\n    // The entry below is added automatically by the framework itself\n    // do not add it manually to avoid compilation errors\n    &quot;/&quot;: (context) =&amp;gt; RouteOne(),\n    &quot;/route-two&quot;: (context) =&amp;gt; RouteTwo(),\n  }\n));\n\n\nAutomatyczna rejestracja nie jest jednak magiczna i związana jest z parametrem home. W przypadku gdy parametr został podany to widget ten będzie wyświetlany dla ścieżki /, jednak jeśli go pominiemy to musimy powiedzieć frameworkowi która ze ścieżek jest początkową, poprzez parametr initialRoute.\n\nrunApp(MaterialApp(\n  initialRoute: &quot;/&quot;,\n  routes: {\n    &quot;/&quot;: (context) =&amp;gt; RouteOne(),\n    &quot;/route-two&quot;: (context) =&amp;gt; RouteTwo(),\n  }\n));\n\n\nW taki właśnie sposób odbywa się dodawanie nowych ekranów w sposób nazwany. A jak zrzucić ekran nowym sposobem? Navigator.popNamed? Nic z tych rzeczy! Operacja typu pop zrzuca aktualny ekran ze stosu, nie musi wiedzieć jaka jest jego nazwa. Zostajemy więc przy starym i sprawdzonym Navigator.pop.\n\nPrzekazywanie danych\n\nJeśli chodzi o sam sposób nawigowania między ekranami to pokryliśmy wszystkie niezbędne aspekty. Do przodu, do tyłu, z małą ilością kodu, bez powtarzania się po całej aplikacji. Czego można chcieć więcej? Cóż, kojarzysz adresy URL w aplikacjach webowych jak np: /users/16, który wyświetla profil użytkownika o identyfikatorze 16? Można zmienić identyfikator na inny dowolny i zobaczyć profil innego użytkownika (o ile istnieje). Dla każdego profilu URL (ścieżka) jest ciut inna, jednak wszystkie kierują na ten sam ekran - różnią się jedynie dane które prezentujemy.\n\nPodobna zależność zachodzi w aplikacjach mobilnych. Weźmy uprzednio wspomnianego Messengera prezentującego listę kontaktów z którymi ostatnio pisaliśmy. Stuknięcie w pozycję kontaktu zabiera nas do konwersacji z daną osobą, a nie do listy wszystkich możliwych wysłanych wiadomości. Ekran szczegółowy otrzymuje informację od ekranu poprzedzającego o identyfikatorze rozmowy którą musi wyświetlić. Przecież Facebook nie jest w stanie zaimplementować całkowicie osobnych ekranów, gdzie jeden będzie prezentował rozmowę z Panią Tereską (pozdrawiam!), a drugi z Panem Krzysiem.\n\nclass BaseChatWidget extends StatelessWidget {}\nclass ChatTereska extends BaseChatWidget {}\nclass ChatKrzysio extends BaseChatWidget {}\nclass ChatMyself extends BaseChatWidget {}\n// ...\n\n\nW celu wysłania dynamicznych danych do ekranu posłużymy się tzw. argumentami. Jest to obiekt przekazywany jako parametr o nazwie arguments do funkcji Navigator.pushNamed i parametryzujący ekran o zdefiniowane dane. A czym mogą być dane? Czymkolwiek. Listą, liczbą, ciągiem znaków, obiektem … Generalnie - wszystkim. Najczęściej jest to  jednak obiekt typu klucz-wartość, którego elastyczność idealnie wpasowuje się w scenariusz nawigacji.\n\n// Totally valid\nNavigator.pushNamed(&quot;/route&quot;, arguments: [1, 2, 3]);\nNavigator.pushNamed(&quot;/route&quot;, arguments: 1);\n// Most popular\nNavigator.pushNamed(&quot;/route&quot;, arguments: {\n  &quot;name&quot;: &quot;John&quot;,\n  &quot;age&quot;: 16,\n});\n\n\nTak będzie wyglądał nasz nowy przycisk wysyłający użytkownika do drugiego ekranu. Wysyłamy argumenty z imieniem i wiekiem, które docelowo wyświetlimy na nowym ekranie.\n\nRaisedButton(\n  child: Text(&quot;Push&quot;),\n  onPressed: () {\n    Navigator.pushNamed(context, &quot;/route-two&quot;, arguments: {\n      &quot;name&quot;: &quot;Kamil&quot;,\n      &quot;age&quot;: 31,\n    });\n  },\n)\n\n\nTyle wystarczy jeśli chodzi o wysłanie danych do nowego ekranu. Dostarczamy argumenty, które są następnie automatycznie przekierowywane do punktu docelowego. Wszystko gra, ale pozostaje pewna kluczowa rzecz która chodzi Ci zapewne po głowie. Co z tego, że dane zostały wysłane skoro nie wiadomo jak je odczytać? Co z tego, że wysłałem rakietę w kosmos jeśli nie mam z nią absolutnie żadnego kontaktu? Czas na …\n\nOdbieranie danych\n\n… odebranie danych w ścieżce docelowej i zrobienie z nich pożytku. Nawet jeśli nie takiego turbo prawdziwego, to chociaż wyświetlimy dane na ekranie. Tak, żeby udowodnić realność odbioru - w prawdziwej aplikacji zrobisz z danymi co Ci się podoba biznes wymyśli.\n\nWyciąganie argumentów odbywa się poprzez przydługie wywołanie ModalRoute.of(context).settings.arguments. W ten sposób uzyskujemy dostęp do obiektu który przekazaliśmy chwilę wcześniej w zawołaniu Navigator.pushNamed. A skoro tak - jesteśmy gotowi do wyświetlenia przekazanych danych na ekranie.\n\nclass RouteTwo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Get the data\n    Map&amp;lt;String, dynamic&amp;gt; args = ModalRoute.of(context).settings.arguments;\n    final name = args[&quot;name&quot;];\n    final age = args[&quot;age&quot;];\n\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Display arguments data\n            Text(&quot;Name: $name&quot;),\n            Text(&quot;Age: $age&quot;),\n            RaisedButton(\n              child: Text(&quot;Pop&quot;),\n              onPressed: () =&amp;gt; Navigator.pop(context),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n\nZakaz powrotu\n\nOstatnią rzeczą związaną z nawigacją we Flutterze którą chcę zaprezentować jest możliwość reagowania na sytuację w której użytkownik wycofuje się z ekranu. Nie ma znaczenia, czy robi to udostępnionym przyciskiem w aplikacji który pod spodem wywołuje Navigator.pop, przyciskiem fizycznym, wirtualnym, czy nawet gestem. Jako programista jesteś w stanie bardzo łatwo zapobiec możliwości cofania się do poprzedniego ekranu - służy do tego widget WillPopScope. Jego działanie jest banalnie proste i wymagana jedynie zdefiniowania parametru onWillPop, który jest funkcją zwracającą informację, czy cofnięcie może zostać wykonane. Inaczej mówiąc jeśli zdefiniowana przez nasz funkcja zwróci true to użytkownik zostanie poprawnie cofnięty, jeśli jednak zwrócimy false to nic się nie wydarzy. Użytkownik zostanie na dotychczasowym ekranie.\n\nWillPopScope(\n  onWillPop: async () =&amp;gt; false,\n  child: Text(&quot;No popping!&quot;),\n);\n\n\nCzy widget ten ma sens? Po co chcielibyśmy blokować użytkownika na ekranie i nie dać mu możliwości powrotu? Okropny UX! Pełna zgoda, jednak funkcjonalność ta przydaje się do warunkowego opuszczania ekranu jak np:\n\n  możesz z niego wyjść dopiero po upływie X czasu\n  po wduszeniu wstecz pojawia komunikat potwierdzający, aby użytkownik nie stracił postępu z obecnego ekranu\n  jakikolwiek inny scenariusz\n\n\nSprawdźmy w praktyce jak działa WillPopScope na prostym przykładzie. Dodamy do aplikacji nowy ekran (route) o nazwie TrapRoute, który uwięzi użytkownika na swoich włościach do momentu aż nie kliknie 5 razy wstecz na telefonie. Nie udostępnimy tam żadnego przycisku cofania - niech będzie to prawdziwa pułapka na nieświadomą ofiarę!\n\nrunApp(MaterialApp(\n  initialRoute: &quot;/&quot;,\n  routes: {\n    &quot;/&quot;: (context) =&amp;gt; RouteOne(),\n    &quot;/route-two&quot;: (context) =&amp;gt; RouteTwo(),\n    &quot;/trap&quot;: (context) =&amp;gt; Trap(),\n  }\n));\n\n\nclass RouteTwo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final args = ModalRoute.of(context).settings.arguments;\n\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceAround,\n        crossAxisAlignment: CrossAxisAlignment.stretch,\n        children: [\n          Text(&quot;Name: $args[&#39;name&#39;]&quot;),\n          Text(&quot;Age: $args[&#39;name&#39;]&quot;),\n          RaisedButton(\n            child: Text(&quot;Pop&quot;),\n            onPressed: () =&amp;gt; Navigator.pop(),\n          ),\n          // New button for trap route\n          RaisedButton(\n            child: Text(&quot;Trap&quot;),\n            onPressed: () =&amp;gt; Navigator.pushNamed(context, &quot;/trap&quot;),\n          ),\n        ]\n      ),\n    );\n  }\n}\n\n\nclass Trap extends StatelessWidget {\n  int backCount = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: WillPopScope(\n          onWillPop: () async {\n            backCount++;\n\n            return backCount &amp;gt;= 5;\n          },\n          child: Image.network(\n            &quot;https://rykowski.dev/assets/img/blog/navigator/trap.jpg&quot;,\n            width: 300,\n            height: 250,\n          )\n      ),\n    );\n  }\n}\n\n\nPułapka gotowa. Użytkownik po wejściu w ekran musi 5x kliknąć wstecz aby z niego wyjść. Zgodnie z planem, ale nie rób tak w produkcyjnej aplikacji. Użytkownicy nie lubią tego typu niespodzianek i jeśli nie mogą się cofnąć to po prostu zamykają cała aplikację. A tego powstrzymać nie możemy.\n"
} ,
  
  {
    "title"    : "Zarządzanie stanem aplikacji - Provider",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-state-management-provider/",
    "date"     : "August 16, 2019",
    "excerpt"  : "Jest to druga część serii o zarządzaniu stanem aplikacji we Flutterze. W poprzednim wpisie rozmawialiśmy o tym czym dokładnie jest stan i w jaki sposób odbywa się jego zarządzanie (state management). Stworzyliśmy prostą grę typu clicker, która kor...",
  "content"  : "Jest to druga część serii o zarządzaniu stanem aplikacji we Flutterze. W poprzednim wpisie rozmawialiśmy o tym czym dokładnie jest stan i w jaki sposób odbywa się jego zarządzanie (state management). Stworzyliśmy prostą grę typu clicker, która korzysta ze stanu, aby móc prezentować wciąż aktualne dane graczowi. Wszystko odbywało się w formie lokalnej, czyli takiej która jest ograniczona wyłącznie do widgetu w którym stan został zadeklarowany.\n\nW dzisiejszym wpisie poznasz zagadnienie nieco bardziej złożone, lecz niezbędne z punktu widzenia średnich i dużych aplikacji. Stan globalny, nazywany również współdzielonym. Cała wiedza którą posiadasz na temat stanu lokalnego (czym jest, jak nim zarządzać) jest jak najbardziej nadal aktualna! Co więcej - jest niezbędna w przyswojeniu nowego konceptu. Jeśli jej nie posiadasz - zapraszam Cię do pierwszej części serii. Zmienia się wyłącznie zakres w obrębie którego mamy dostęp do naszego stanu. Przechodzimy z zasięgu per widget na per drzewo.\n\n\n\nStan lokalny vs stan globalny\n\nWyróżniamy dwa rodzaje stanu aplikacji - lokalny i globalny. Nie ma w tych pojęciach nic podchwytliwego i oznaczają właśnie to co sugeruje ich nazwa. Różnica między nimi jest taka jak między zmienną prywatną, a publiczną w kodzie - chodzi o zasięg określający gdzie dokładnie można skorzystać z danego stanu, czy zmiennej. Jest to co prawda spore uproszczenie, ale warto trzymać je z tyłu głowy aby mieć na start jakikolwiek punkt odniesienia (później możesz go wyrzucić z głowy).\n\nWiększość aplikacji korzysta z obu tych wariantów, pomimo tego, że zawsze istnieje sposób aby napisać projekt w kompletnym oparciu się tylko o jeden z nich. Dlaczego więc programiści komplikują sobie życie i nie wybierają jedynego słusznego rozwiązania? Bo takowe nie istnieje i wszystko zależy od rodzaju danych, którymi chcemy zarządzać. Zawsze dobieraj odpowiednie narzędzie do konkretnej sytuacji.\n\n\n  To że bułkę można przekroić nożyczkami, nie znaczy że jest to najlepszy sposób. Nie strzelaj sobie w kolano i dobieraj rodzaj stanu według aktualnych potrzeb. Nie daj się również ocyganić, że stan lokalny to anty-pattern.\n\n\nStan lokalny\n\nZarządzanie stanem lokalnym we Flutterze odbywa się poprzez dobrze nam już znany StatefulWidget. Stan lokalny to zestaw danych wykorzystywany wyłącznie na potrzeby pojedynczego ekranu (precyzyjniej - widgetu), gdzie nie ma potrzeby, aby inne komponenty w aplikacji zaprzątały sobie nim głowę, lub miały do niego dostęp.\n\nIdealnym przykładem może być odliczanie czasu do rozpoczęcia rozgrywki w dowolnej grze mobilnej. Gracz wybiera postać oraz poziom na którym chce zagrać, a następnie pojawia się ekran typu “3 … 2 … 1 … Start!” mający dać mu chwilę na przygotowanie. Informacja o tym ile sekund pozostało do rozpoczęcia potyczki jest najprawdopodobniej istotna wyłącznie dla aktualnego ekranu - żaden inny nie będzie tą informacją zainteresowany i udostępnianie jej to strata czasu i często over-engineering.\n\n\n\n\n  Używaj śmiało stanu lokalnego wszędzie tam, gdzie nie chcesz go współdzielić między różnymi widgetami. Wybór leży po Twojej stronie i może się okazać, że nawet powyższy timer ma sens na trafienie do nieba stanu globalnego.\n\n\nKiedy stan lokalny przestaje się sprawdzać? Przy złożonej aplikacji rośnie nam głębokość drzewa rysowanych widgetów i schodzimy coraz niżej w dół. Pojawia się także sporo własnych klas widgetów, aby zachować jakość i czytelność kodu. W tym wszystkim zachodzi komunikacja między widgetami na różnym poziomie. Wduszam przycisk A na dole strony, a na górze pojawiają się nowe wartości. Zmieniam język na ekranie ustawień, a przez to cała reszta aplikacji jest po polsku.\n\n\n\n\n  Diagram przedstawiający główny problem stanu lokalnego. W jaki sposób przekazać wartość Username do WidgetA1 i WidgetB1 bez ręcznego przekazywania przez wszystkie warstwy w stylu MyApp -&amp;gt; HomePage -&amp;gt; WidgetA -&amp;gt; WidgetA1, a dodatkowo umożliwić zmianę tego pola z dowolnego miejsca drzewa?\n\n\nCo z tym fantem zrobić? Gdzie trzymać ich wspólny stan? Co w przypadku gdy musisz dzielić się danymi pomiędzy różnymi komponentami systemu? Oto zadanie specjalne dla …\n\nStan globalny\n\n… stanu globalnego! Podobnie jak w przypadku stanu lokalnego, Flutter również tutaj dostarcza własny i wbudowany mechanizm w postaci InheritedWidget. Przechowuje on stan w taki sposób, że niemal każdy widget jest w stanie go samodzielnie odczytać i przebudować się w razie potrzeby. Czy oznacza to więc, że będziemy go używać w dalszej części wpisu? Otóż nie tym razem. Widget ten jest dość niskopoziomowy i niezbyt przyjemy w codziennym użytkowaniu. W moim odczuciu wymaga zbyt wiele kodu, aby zrealizować nawet najprostszy efekt.\n\nWłaśnie dlatego powstała biblioteka Provider, której głównym zadaniem jest dostarczenie tzw. lukru składniowego (syntax sugar) na wbudowany i toporny InheritedWidget. Cel swój realizuje w 100% - praca z nią jest przyjemna i szybka, a dodatkowo została namaszczona przez Google jako niemal oficjalne rozwiązanie do zarządzania stanem. Solidna rekomendacja.\n\n\n\nDo Providera wrócimy w dalszej części, spójrz jednak na gifa umieszczonego powyżej. Mamy w nim uwzględnione trzy różne ekrany przez które przechodzi gracz.\n\n\n  Skrolowalna lista kategorii z której wybierana jest dowolna pozycja. W stanie globalnym przechowujemy pełną listę kategorii (categories) oraz informację o aktualnie zaznaczonej (active_category), która w obecnej chwili jest pusta (null). Po stuknięciu w dowolny element, active_category zyska wartość, która może być następnie odczytywana przez inne widgety.\n\n\n\n\n\n  Detal kategorii prezentujący aktualny wybór z grafiką i dodatkowym opisem. W celu prezentacji odpowiednich danych wykorzystywany jest stan active_category, aby określić identyfikator aktywnej kategorii (12), a następnie lista categories jest przeszukiwania pod kątem danego identyfikatora, aby wyszukać pełny obiekt*. Użytkownik ma również możliwość zmiany czasu rundy (30-60-90-120), która także przechowywana jest w globalnym stanie.\n\n\n\n\n*Pod kątem wydajnościowym lepiej byłoby przechowywać strukturę w formie mapy, gdzie kluczem jest identyfikator, a wartością obiekt z danymi. Nie ma to jednak znaczenia pod względem merytorycznym.\n\n\n  Ekran końcowy na którym w górnej części widoczna jest nazwa wybranej kategorii to ponownie tandem active_category+categories. W dolnej widoczny jest pozostały czas rundy, która rozpoczyna odliczanie od wartości round_time. Czas pozostały do końca gry nie jest trzymany w stanie globalnym, a jedynie w lokalnym - inne widgety nie będą potrzebowały go konsumować w żadnym celu.\n\n\n\n\nEkrany #2 i #3 potrzebują w jakiś sposób uzyskać informację, jaka kategoria została wybrana na ekranie #1, a ekran #3 potrzebuje dodatkowo wiedzieć jaki jest maksymalny czas rundy z ekranu #2. Jako, że są to widgety całkowicie od siebie niezależne nie możemy wykorzystać stanu lokalnego - w takim przypadku tylko ekran #1 wiedziałby która z kategorii jest aktywna, pozostałe żyłyby w niewiedzy. A wiedza ta jest im niezbędna do zaprezentowania poprawnej grafiki, czy nazwy.\n\nTym właśnie zajmuje się stan globalny. Dba o to, aby wskazane dane były ogólnodostępne dla wszystkich zainteresowanych. Zajmuje się także (jak to stan) informowaniem o wszelkich zmianach, aby możliwe było automatyczne przebudowanie widgetów. Zupełnie jak wywołanie setState.\n\n\n  Nie przejmuj się jeśli w głowie masz pytania o to który stan powinien być globalny, a który lokalny. Początkowo wszystko może być lokalne, a następnie zrefaktorowane gdy najdzie taka potrzeba. Z czasem nabierzesz fachowego przeczucia i określanie zasięgu będzie przychodziło naturalnie. Nie lubię frazesów, ale Praktyka czyni mistrza.\n\n\nProvider\n\nJednym z najpopularniejszych i przystępnych narzędzi we Flutterze do zarządzania stanem globalnym jest wspomniana już paczka Provider. Przychylność developerów zyskała  dzięki niskiemu progowi wejścia oraz minimalną ilością kodu, którą trzeba wklepywać raz-po-raz, a nie jest związana bezpośrednio z logiką naszej aplikacji. Chodzi fachowo o boilerplate - kod którego każdy chce unikać jak ognia. Nie ma go tutaj praktycznie wcale, co skutkuje tym, że mamy mniej kodu do utrzymania. WIN-WIN. Ciekawa jest również sama historia która stoi za biblioteką, którą możesz prześledzić na GitHubie.\n\nTL;DR Google w podobnym czasie co Remi (authora Providera) pracował nad bliźniaczym rozwiązaniem. Wycofał się jednak z niego i pobłogosławił Providera jako “oficjalne” rozwiązanie..\n\nStarczy jednak tego wywodu teoretyczno-historycznego. Zajmijmy się tym co naprawdę istotne. Co robi ten cały Provider i jak nam pomoże w pisaniu aplikacji mobilnej? Pora na warsztaty!\n\nPrzygotowanie aplikacji\n\nUsiądźmy do praktycznego przykładu, aby lepiej poznać niezbędne tajniki stanu globalnego. Nie weźmiemy na warsztat co prawda aplikacji z powyższego gifa, bo jest zbyt skomplikowana jako punkt referencyjny. Zbyt wiele się w niej dzieje. Wolę abyśmy skupili się jedynie na tym co jest naprawdę istotne, czyli kwestii zarządzania stanem. Co więc proponuję? Colorek - mini program do mieszania kolorów.\n\n\n\n  Colorek w wersji 1.0.0\n\n\nAplikacja polega na dobieraniu proporcji trzech bazowych kolorów przy pomocy suwaków. W trakcie doboru są one mieszane i prezentowane jako pojedynczy kolor RGB (Red Green Blue) na dole ekranu. Jeśli nie słyszałeś nigdy o RGB - jest to model kolorystyczny w którym dobieramy wartości trzech tytułowych kolorów z przedziału od 0 do 255, a z mieszanki tej powstaje kolor wynikowy. Skrajnymi kolorami są biały (wszystkie wartości na 0) oraz czarny (255).\n\nAle, ale! Gdzie tu jest niby stan globalny? Wszystko jak na dłoni widać na pojedynczym ekranie, można to więc ograć stanem lokalnym i zakończyć materiał szkoleniowy. No niby tak, ale nie do końca. Można by się pokusić o użycie stanu lokalnego - jak zawsze. Jednak z punktu widzenia dobrych praktyk i tego że najłatwiej się uczyć na prostych przykładach zostaniemy przy nim. Zaufaj mi, że to pierwszy krok ku lepszemu światu i nieograniczonym możliwościom.\n\nPunkt wejściowy (main.dart)\n\nPlik main.dart wykorzystamy jedynie jako punkt wejściowy do aplikacji. W trakcie dalszej implementacji będzie rozszerzany o dodatkowe konfiguracje, ale bez żadnej logiki, czy stylowania. Na start jego głównym zadaniem będzie narysowanie widgetu HomePage. Nie jest to widget wbudowany we Fluttera, musimy go za chwilę sami zakodować.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nimport &#39;pages/home_page.dart&#39;;\n\nvoid main() =&amp;gt; runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: &#39;Provider Demo&#39;,\n      home: HomePage(),\n    );\n  }\n}\n\n\n\n  Nie ma magii, nie ma czarów. Prosty bezstanowy widget, który niemal nic nie robi. Zwróć jedynie uwagę, że HomePage pochodzi z innego pliku (import).\n\n\nEkran główny (pages/home_page.dart)\n\nStwórzmy katalog pages, a w nim plik home_page.dart. Będzie to nasz widget reprezentujący ekran główny aplikacji - rysowany zaraz po jej uruchomieniu. Zwróć uwagę, że pomimo faktu bycia widgetem wyświetlającym pełny ekran (w praktyce - złożonym) nie jest on stanowy. Taki też pozostanie.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nimport &#39;../components/rgb_slider.dart&#39;;\nimport &#39;../components/rgb_preview.dart&#39;;\n\nclass HomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: [\n          RGBSlider(),\n          Expanded(\n            child: RGBPreview(),\n          )\n        ],\n      ),\n    );\n  }\n}\n\n\nW celu rozproszenia odpowiedzialności rozbiliśmy nasz ekran na dwa główne komponenty, które same sobie rzepkę skrobią:\n\n\n  RGBSlider - część służąca do zmiany wartości kolorów przy pomocy interaktywnych suwaków.\n  RGBPreview - podgląd koloru wynikowego, który aktualizuje się automatycznie na zmianę wartości w stanie aplikacji.\n\n\nMożliwe że zapaliła Ci się mała lampka kontrolna patrząc na powyższy przykład. Wygląda na tyle prosto, że z tego miejsca mógłbyś zakopać pomysł o globalnym stanie, a samo rozwiązanie oprzeć o stan lokalny. Ot poprosisz HomePage żeby przytrzymał Ci piwo wartości kolorów, które przekażesz manualnie w dół do RGBSlider i RGBPreview a slider dostanie jeszcze funkcje do ich zmiany. Właśnie tak:\n\nimport &#39;package:flutter/material.dart&#39;;\n\nimport &#39;../components/rgb_slider.dart&#39;;\nimport &#39;../components/rgb_preview.dart&#39;;\n\nclass HomePage extends StatefulWidget {\n  HomePage({Key key}) : super(key: key);\n\n  @override\n  HomePageState createState() =&amp;gt; HomePageState();\n}\n\nclass HomePageState extends State&amp;lt;HomePage&amp;gt; {\n  int red = 0;\n  int green = 0;\n  int blue = 0;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n        children: [\n          RGBSlider(\n            red: red,\n            onRedChange: (value) =&amp;gt; setState(() { red = value; }),\n            green: green,\n            onGreenChange: (value) =&amp;gt; setState(() { green = value; }),\n            blue: blue,\n            onBlueChange: (value) =&amp;gt; setState(() { blue = value; }),\n          ),\n          Expanded(\n            child: RGBPreview(\n              red: red,\n              green: green,\n              blue: blue,\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\n\n\nZadziała? Pewnie że tak! Czy jest to dobre rozwiązanie? Być może. Czy stan globalny będzie lepszym wyborem? To zależy. Powyższa struktura wygląda mocno pokracznie - co zrobisz gdy będzie trzeba przekazać kolory jeszcze jeden poziom w dół? Kod spaghetti. Właśnie dlatego z zaciekawieniem patrzymy na stan globalny.\n\nDo pełni możliwości skompilowania projektu - a to pierwszy krok ku temu aby działał poprawnie - brakuje nam już tylko dwóch rzeczy. A raczej widgetów. Wspomniamy RGBSlider i RGBPreview, które umieścimy w katalogu components stworzonym na tym samym poziomie co pages.\n\n\n\n  Struktura projektu. Pojawiają się w niej details_page.dart oraz login_page.dart, które możesz narazie zignorować. Są to zadania bonusowe do zrobienia w formie pracy domowej.\n\n\nModyfikator kolorów (components/rgb_slider.dart)\n\nTrzy suwaki gdzie każdy służy do określenia wartości innego koloru. Jako, że są to widgety bliźniacze i różnią je jedynie drobne szczegóły (np. wyświetlany tekst, czy kolor suwaka) - skorzystamy z funkcji pomocniczej buildSlider. Narysuje ona pojedynczy suwak na ekranie z odpowiednią konfiguracją.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nclass RGBSlider extends StatelessWidget {\n  Widget buildSlider(\n      {String label, Color color, double value, Function onChanged}) {\n    return Padding(\n      padding: const EdgeInsets.only(bottom: 16),\n      child: Column(\n        children: [\n          Text(label),\n          Slider(\n            value: value,\n            min: 0,\n            max: 255,\n            onChanged: onChanged,\n            activeColor: color,\n          ),\n        ],\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        buildSlider(\n          label: &quot;Red&quot;,\n          color: Colors.red,\n          value: 0,\n          onChanged: (value) =&amp;gt; print(&quot;Red $value&quot;),\n        ),\n        buildSlider(\n          label: &quot;Green&quot;,\n          color: Colors.green,\n          value: 0,\n          onChanged: (value) =&amp;gt; print(&quot;Green $value&quot;),\n        ),\n        buildSlider(\n          label: &quot;Blue&quot;,\n          color: Colors.blue,\n          value: 0,\n          onChanged: (value) =&amp;gt; print(&quot;Blue $value&quot;),\n        ),\n      ],\n    );\n  }\n}\n\n\nDo funkcji buildSlider przekazujemy dwa kluczowe parametry odpowiadające za jego działanie: wartość (value) i funkcję do uruchomienia gdy wartość powinna się zaktualizować (onChanged). Nasza wartość jest zawsze zerem, a gdy dostajemy informację że powinniśmy ją zaktualizować - robimy printa. Wszystko prawie dobrze, ale można by to zrobić delikatnie lepiej (bardziej działająco).\n\nPodglądacz koloru (components/rgb_preview.dart)\n\nNaprostszy możliwy widget we Flutterze w postaci kolorowego kwadratu. A my go jeszcze honorujemy własnym plikiem i dumną nazwą RGBPreview. Nie da się jednak ukryć że robi to co sugeruje, czyli wyświetla podgląd kolorystyczny.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nclass RGBPreview extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Container(\n        width: 200,\n        height: 200,\n        color: Color.fromRGBO(11, 7, 218, 1),\n      ),\n    );\n  }\n}\n\n\nColor.fromRGBO(11, 7, 218, 1) wygeneruje nam kolor, który składa się z 11 jednostek czerwonego, 7 zielonego, 218 niebieskiego. Jedynka na końcu określa przezroczystość, a raczej jej brak.\n\n\n\n  Colorek w wersji 0.0.1-alpha\n\n\nWłaśnie w tym miejsciu kończymy nieciekawy boilerplate w postaci części wizualnej i rozpoczynamy oprogramowanie stanu. Aplikacja już w tym momencie powinna się poprawnie budować, zachęcam Cię do sprawdzenia, abyśmy na pewno byli w tym samym punkcie. Nie działa jednak jeszcze prawidłowo, czas to zmienić!\n\nDostarczanie stanu\n\nMamy już przygotowany pełen layout aplikacji, a nie dotknęliśmy jeszcze nawet w najmniejszym stopniu kwestii stanu. O to się nie martw. Właśnie teraz, w tym momencie rozpoczynamy proces nadrabiania strat i wyrównywania szans. Pora na turbo dawkę wiedzy praktycznej dotyczącej stanu globalnego, a w szczególności Providera. Ożywmy nasz projekt! ⚡\n\nZarządzanie stanem w Providerze wymaga trzech bazowych elementów:\n\n\n  Dostawca (Provider) - widget umieszczony na górze drzewa i propagujący swoje dane (stan) nieprzerwanie w dół do zainteresowanych odbiorców.\n  Odbiorca (Consumer) - element ulokowany na dole drzewa i nasłuchujący wskazanych dostawców (jednego lub wielu). Poza odczytem, może także zmieniać dostarczony stan oraz automatycznie się przebudować na dowolną jego zmianę.\n  Stan (State) - paczka z danymi która wędruje od dostawcy do odbiorcy.\n\n\nObrazową analogią wymienionych elementów jest klasyczna gra Donkey Kong z NES-a (lokalnie zwanego pegazusem). Tytułowy goryl (dostawca) miota w dół planszy (drzewa) beczkami (stanem), które Mario (odbiorca) łapie aby dowiedzieć się co jest w środku. Gdy tylko Mario złapie beczkę zmienia swój stan - ginie, umiera, znika na zawsze. Główna różnica polega na tym, że Mario nie chce zmieniać swojego stanu (nie dziwi mnie to). My chcemy! Będziemy więc łapać interesujące nas “beczki” i aktualizować w locie warstwę prezentacyjną.\n\n\n\nInstalacja zależności\n\nW pliku pubspec.yaml dodaj nową zależność i zainstaluj ją:\ndependencies:\n  provider: ^3.0.0+1\n\n\nNie wiesz jak zainstalować dodaną zależność? W konsoli przejdź do katalogu projektu i wykonaj następującą komendę:\n\nflutter pub get\n\n\nStan (state)\n\nPierwszym elementem łańcucha który weźmiemy na warsztat jest stan. Definiujemy go poprzez utworzenie własnej klasy rozszerzającej Flutterowy ChangeNotifier. Jest to bazowa klasa, która udostępnia ogólne API do powiadamiania o zmianach - idealnie więc wpasowuje się w tematykę zmiany stanu.\n\nTuż obok main.dart stwórzmy plik models.dart w którym przechowamy definicję stanu dla kolorów.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nclass ColorModel extends ChangeNotifier {\n  double _red = 0;\n  double _green = 0;\n  double _blue = 0;\n\n  double get red =&amp;gt; _red;\n  set red(double value) {\n    _red = value;\n    notifyListeners();\n  }\n\n  double get green =&amp;gt; _green;\n  set green(double value) {\n    _green = value;\n    notifyListeners();\n  }\n\n  double get blue =&amp;gt; _blue;\n  set blue(double value) {\n    _blue = value;\n    notifyListeners();\n  }\n}\n\n\nPowyższa klasa przechowuje informacje o wartościach trzech kolorów: czerwony, zielony, niebieski. Pola zdefiniowane są jako prywatne (poprzedzone znakiem _), aby nikt poza klasą nie mógł ich zmienić w sposób niekontrolowany. Jest to ostatnia rzecz jakiej potrzebujesz w swojej aplikacji. Kontrolowany stan to dobry stan.\n\nPubliczny odczyt (get) odbywa się po identycznej nazwie jak nazwa pola prywatnego z tym że bez podkreślnika - standardowy zabieg. W celu odczytu wartości pola double _red, poprosisz po prostu o model.red, gdzie model to instancja klasy. Publiczna zmiana (set) dokonuje stosownej zmiany pola (norma), a dodatkowo wywołuje notifyListeners(), aby poinformować o zmianie wszystkich zainteresowanych odbiorców. W ten sposób kontrolujemy wartość stanu, a dodatkowo to jakie informacje mają w danym czasie wszyscy odbiorcy.\n\nMoglibyśmy rzecz jasna zaimplementować wszystko bez gettera i settera. Dzięki takiemu zabiegowi kod będzie znacząco krótszy …\n\nimport &#39;package:flutter/material.dart&#39;;\n\nclass ColorModel extends ChangeNotifier {\n  double red = 0;\n  double green = 0;\n  double blue = 0;\n}\n\n\n… ale jednocześnie niedziałający w sposób jakiego oczekujemy. Można co prawda zmieniać dowolnie wartości kolorów, ale żaden odbiorca nie zostanie o tym fakcie poinformowany, bo brakuje w kluczowym momencie wywołania notifyListeners(). Po co zmieniać stan, skoro aplikacja nie może na niego zareagować? Fajna ta implementacja, taka nie za mądra.\n\n\n  Reasumując - lepsza dłuższa implementacja która działa, niż krótsza która nie robi nic.\n\n\nPracując z klasą stanu pamiętaj o kilku prostych trikach zasadach:\n\n\n  Przerysowanie drzewa odbędzie się tylko gdy spełnione są następujące kryteria:\n    \n      Aktualnie wyświetlany widget zarejestrował się jako odbiorca (o tym w kolejnej sekcji)\n      Klasa stanu uruchomi funkcję notifyListeners(), która jest kluczowa z punktu widzenia zarządzania stanem. Można ją przyrównać do setState, który również przebudowuje fragment drzewa.\n    \n  \n  Każdorazowe zawołanie notifyListeners() prowadzi do przebudowania zależnych widgetów. Nie wykonuj go więc częściej niż naprawdę potrzebujesz. Unikaj sytuacji w której pojedyncza funkcja zmieniająca stan wywołuje ją więcej niż jeden-dwa razy.\n  Do wykonania akcji na stanie (np. zmiana koloru) wymagane jest zarejestrowanie się jako odbiorca. Nie możesz zmienić globalnego stanu, nie będąc jego odbiorcą. Kropka.\n\n\nDostawca (provider)\n\nDostawca jest widegetem nadrzędnym, który umieszczony w dowolnym miejscu drzewa, propaguje/informuje wszystkie swoje dzieci (również te zagnieżdzone X poziomów w dół) o aktualnym stanie aplikacji.\n\nPomimo tego, że dostawca może być umieszczony w dowolnym miejscu drzewa, w praktyce często definiuje się go bezpośrednio w pliku konfiguracyjnym main.dart. Chodzi o to, aby umieścić go w szczytowym miejscu drzewa (korona drzewa?) skąd jest w stanie obsłużyć całą aplikację bez wyjątku.\n\nPrzejdźmy do pliku main.dart, aby skonfigurować dostawcę stanu dla aplikacji.\n\nPrzed:\nvoid main() =&amp;gt; runApp(MyApp());\n\n\nPo:\nimport &#39;package:provider/provider.dart&#39;;\n\nimport &#39;models.dart&#39;;\n\nvoid main() =&amp;gt; runApp(\n  MultiProvider(\n    providers: [\n      ChangeNotifierProvider(builder: (context) =&amp;gt; ColorModel()),\n    ],\n    child: MyApp(),\n  ),\n);\n\n\nDo osadzenia potrzebujemy trzech rzeczy:\n\n  MultiProvider widget rejestrujący wielu dostawców na raz. Klasyczny syntax sugar, który jedynie upraszcza sposób rejestracji - można to robić również jeden po drugim (ale wymaga więcej kodu).\n  ChangeNotifierProvider pojedynczy dostawca stanu, budowany na podstawie klasy pochodnej od ChangeNotifier.\n  ColorModel  klasa przechowująca stan, którą dopiero co utworzyliśmy.\n\n\nAlternatywnym (i krótszym) rozwiązaniem jest pominięcie MultiProvider. Ma on realne zastosowanie tylko gdy mamy więcej niż jedną klasę stanu, a bazowa wersja Colorka nie jest na tyle złożona aby jej wymagała.\n\nvoid main() =&amp;gt; runApp(\n  ChangeNotifierProvider.value(\n    value: ColorModel(),\n    child: MyApp(),\n  )\n);\n\n\nOdbiorca (consumer)\n\nJesteśmy na etapie w którym mamy zbudowany layout oraz dwie z trzech częsci stanu. Aplikacja poprawnie się buduje i uruchamia na emulatorze, bądź urządzeniu. Nie jest jednak interaktywna. Brakuje ostatniego klocka w wieży lego, ostatniej nutki w symfonii. Jest nim odbiorca stanu. Coś co konsumuje stan i wyświetla go na ekranie, a rownocześnie moze go aktualizować jeśli uzna że istnieje taka potrzeba.\n\nPrzed rozpoczęciem konsumowania stanu wymagany jest … import biblioteki. Wiadomo - przy dostawcy zrobiliśmy to samo, ale chcę mieć pewność że o tym pamiętasz. W każdym pliku który korzystać będzie z Providera potrzebujemy poniższego importu.\n\nimport &#39;package:provider/provider.dart&#39;;\n\n\nPozostało nam jedynie wybranie sposobu w jaki skonsumujemy dostępny stan. Wybranie? Tak. Provider dostarcza dwa niezależne sposoby na to, aby móc korzystać i operować stanem. Są one bardzo zbliżone, niemal identyczne - różnią je jak zawsze detale implementacyjne.\n\n\n  Żaden ze sposobów nie jest lepszy, lub gorszy. Mają delikatnie różne zastosowanie, jednak osobiście częściej korzystam z Consumera.\n\n\nProvider.of\n\nPierwszym sposobem na korzystanie ze stanu jest statyczna funkcja Provider.of. Wymaga ona podania klasy stanu którą chcemy odnaleźć, oraz aktualnego kontekstu. Dodatkowo przyjmuje specjalną flagę listen (domyślnie true), która określa czy widget który wywołał funkcję będzie automatycznie przebudowywany po jakiejkolwiek zmianie stanu w obrębie odnalezionej klasy.\n\nProvider.of&amp;lt;ColorModel&amp;gt;(\n  context, listen: true,\n)\n\n\nZwraca instancję stanu z której możemy wyciągnąć interesujące dane, a dodatkowo wywoływać dowolne metody na nim występujące. Widget na poziomie którego wykonamy to polecenie będzie automatycznie przebudowywany za każdym razem gdy w ColorModel wywołana zostanie funkcja notifyListeners().\n\nProvider.of&amp;lt;ColorModel&amp;gt;(\n  context, listen: false,\n)\n\n\nAnalogicznie jak powyżej, z tą różnicą że widget nigdy automatycznie się nie przebuduje. Używaj z rozwagą - wyłącznie w przypadkach gdy chcesz zmieniać stan, ale bezpośrednio od niego nie zależysz (nie wyświetlasz go).\n\nProsty przykład:\n\nvar state = Provider.of&amp;lt;ColorModel&amp;gt;(context, listen: true);\n\nreturn RaisedButton(\n  child: Text(state.red),\n  onPressed: () =&amp;gt; state.red++;\n);\n\n\nZalety:\n\n  Mało kodu\n  Możliwość operowania stanem bez konieczności przebudowania\n\n\nWady:\n\n  Zmiana stanu powoduje przebudowanie całego widgetu odbiorcy\n\n\nW celu zademonstrowania działania na żyjącym organizmie, użyjmy tego sposobu zapisu do obsługi suwaków. Przejdźmy do pliku components/rgb_slider.dart i wymieńmy całkowicie metodę build.\n\nimport &#39;../models.dart&#39;;\n\n// ...\n\n@override\nWidget build(BuildContext context) {\n  var color = Provider.of&amp;lt;ColorModel&amp;gt;(context, listen: true);\n\n  return Column(\n    children: [\n      buildSlider(\n        label: &quot;Red&quot;,\n        color: Colors.red,\n        value: color.red,\n        onChanged: (value) =&amp;gt; color.red = value,\n      ),\n      buildSlider(\n        label: &quot;Green&quot;,\n        color: Colors.green,\n        value: color.green,\n        onChanged: (value) =&amp;gt; color.green = value,\n      ),\n      buildSlider(\n        label: &quot;Blue&quot;,\n        color: Colors.blue,\n        value: color.blue,\n        onChanged: (value) =&amp;gt; color.blue = value,\n      ),\n    ],\n  );\n}\n\n\nCo zmieniło się w porównaniu z poprzednią wersją? Niewiele. Do funkcji buildSlider przekazujemy prawdziwą wartość koloru pobraną ze stanu, a także funkcję która będzie aktualizować na bieżąco dany kolor. Przyznaj sam, że jest to naprawdę mała ilość kodu i trudno sobie wyobrazić go mniej.\n\nOd teraz po uruchomieniu aplikacji możesz targać suwakami na lewo/prawo i zmienią one swoje położenie. Wartość każdego koloru jest ogólnodostępna, a nie tylko zamknięta do aktualnego widgeta. W praktyce oznacza to, że jesteśmy o krok od skonsumowania stanu w components/rgb_preview.dart. Spójrzmy jednak na alternatywny sposób konsumcji.\n\nConsumer\n\nJak to we Flutterze - wszystko jest widgetem, Provider też może zostać tak wykorzystany. Otrzymujemy z pudełka widget Consumer, który działa na zasadzie buildera - zamiast parametru child występuje builder, będący funkcją uruchamianą w trakcie budowania drzewa (w uproszczeniu).\n\nBuilder przyjmuje łącznie trzy parametry, z czego istotne dla nas będą tylko dwa pierwsze:\n\n\n  context - dobrze znany BuildContext w ramach którego budowane jest drzewo.\n  value - instanacja stanu o który pytaliśmy. Identyczny obiekt jak ten uzyskany przez Provider.of.\n\n\nOstatni argument nazwaliśmy lakonicznie _ co jest konwencją języka Dart na parametr który wiemy że istnieje, ale stanowczo nie będziemy go do niczego wykorzystywali.\n\nProsty przykład:\n\nreturn Consumer&amp;lt;ColorModel&amp;gt;(\n  builder: (context, value, _) {\n    return RaisedButton(\n      child: Text(value.red),\n      onPressed: () =&amp;gt; value.red++;\n    );\n  }\n);\n\n\nZalety:\n\n  Jest widgetem\n  Umożliwia przebudowywanie tylko fragmentu drzewa\n\n\nWady:\n\n  Zawsze nasłuchuje na zmiany stanu (konieczne rebuildy)\n\n\nCzas na deser i finalizację aplikacji. Wykorzystamy jeden prosty trik, aby narysować podgląd koloru wybranego przez użytkownika. Przejdźmy tym razem do pliku components/rgb_preview.dart i skorzystajmy z Consumera.\n\nimport &#39;../models.dart&#39;;\n\n// ...\n\n@override\nWidget build(BuildContext context) {\n  return Consumer&amp;lt;ColorModel&amp;gt;(\n    builder: (context, color, _) {\n      return Center(\n        child: Container(\n          width: 200,\n          height: 200,\n          color: Color.fromRGBO(\n            color.red.toInt(),\n            color.green.toInt(),\n            color.blue.toInt(),\n            1,\n          ),\n        ),\n      );\n    },\n  );\n}\n\n\nOtoczyliśmy nasz poprzedni kod builderem Consumer i zamiast przekazywać losowe wartości poszczególnych kolorów - używamy tych które zapisane są w stanie. Mogliśmy użyć co prawda Provider.of - chcę jednak abyś wiedział że możesz ich używać zamiennie w oparciu o ich wady/zalety.\n\nAplikacja działa już teraz w 100%. Osiągnęliśmy zamierzony cel i mimo tego, że nie jest to cud techniki to masz teraz solidną wiedzę odnośnie pełnego zarządzania stanem - możesz zbudować jakąkolwiek apkę sobie wymarzysz (tylko nie przesadzaj).\n\nPodsumowanie\n\nOto i cały Provider w pigułce. Jest ktoś na górze drzewa kto dostarcza aktualny stan (dostawca), jest także ten który czeka na dole drzewa i nasłuchuja na zmiany (odbiorca). Jest też ostatecznie sam stan wysyłany od dostawcy do odbiorcy.\n\nPrzypomnienie jak korzystać z providera:\n\n\n  W pliku main.dart (lub innym wybranym) dodaj nowy wpis do MultiProvider.\n  Zdefiniuj klasę stanu dziedziczącą po ChangeNotifier.\n  W dowolnym widgecie w drzewie poniżej użyj Provider.of lub Consumer aby móc korzystać ze stanu.\n  Pamiętaj o wywołaniu notifyListeners(), aby wymusić przebudowanie drzewa.\n\n\nPełny kod aplikacji znajdziesz jak zawsze na GitHubie. A co dalej z projektem? Jak go rozbudować, aby upewnić się, że opanowałeś w pełni zarządzanie stanem? Oto kilka pomysłów które po części uwzględniłem w referencyjnej aplikacji:\n\n\n  Dodanie ekranu logowania w którym użytkownik podaje swoją nazwę przed rozpoczęciem wyboru kolorów.\n  Wyświetlanie na wszystkich kolejnych ekranach nazwy użytkownika w belce aplikacji (AppBar).\n  Po stuknięciu w podgląd koloru przeniesienie użytkownika na kolejny ekran prezentujący te same dane ale w inny sposób (bez suwaków? podgląd w formie koła zamiast kwadratu?).\n  Dodanie nowego suwaka do ustawiania przezroczystości i uwzględnienie tej wartości w podglądzie (ostatni parametr funkcji Color.fromRGBO).\n  … i wiele więcej - ogranicza Cię tylko wyobraźnia (i ograniczenia sprzętowe).\n\n\n\n"
} ,
  
  {
    "title"    : "Zarabianie i monetyzacja - Reklamy AdMob",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-monetization-admob/",
    "date"     : "July 17, 2019",
    "excerpt"  : "Pisanie aplikacji mobilnych to świetna zabawa. Tworzenie czegoś z myślą, że będzie używane przez setki, tysiace, a nawet miliony ludzi pobierajacych naszą apkę ze sklepów to mieszanka dumy, ekscytacji i czystego fun-u. Tak to wygląda przynajmiej z...",
  "content"  : "Pisanie aplikacji mobilnych to świetna zabawa. Tworzenie czegoś z myślą, że będzie używane przez setki, tysiace, a nawet miliony ludzi pobierajacych naszą apkę ze sklepów to mieszanka dumy, ekscytacji i czystego fun-u. Tak to wygląda przynajmiej z naszej strony - czysto technicznej. Wypuszczamy aplikację, dopieszczamy ją o nowe funkcjonalności i rozwiązujemy najbardziej krytyczne, lub uciążliwe błędy. Zastanawiałeś się jednak czy jest coś więcej? Coś ważniejszego?\n\n\n  Druga strona medalu - strona biznesowa.\n\n\nMoże to zabrzmieć brutalnie, zwłaszcza z ust programisty - przecież jestem jednym z Was! Warstwa biznesowa jest stroną nadrzędna, a technologia powinna służyć biznesowi w osiąganiu wyznaczonych celów, nie na odwrót. Jakie cele może mieć biznes? Bo cele techniczne są nam w większości znane:\n\n\n  Czysty i schludny kod\n  Korzystanie z nowych narzędzi/frameworków\n  Posiadanie dużego pokrycia testami\n  Automatyzacja powtarzających się czynności (np. build aplikacji)\n  I wiele, wiele więcej.\n\n\n\n  Biznes ma jeden kluczowy cel - zarabianie $$$. To między innymi z tych środków bierze się Twoja i moja wypłata.\n\n\nSposoby monetyzacji\n\nO tym właśnie przeczytasz w tym wpisie. O zarabianiu na aplikacjach mobilnych, czyli jak monetyzować użytkowników. O tym w jaki sposób “wycisnąć” trochę grosza, nawet z hobbistycznego projektu robionego po godzinach. W sposób etyczny i co ważniejsze nienachalny, abyś nie wstydził się swojego dzieła przed (nie)znajomymi. W jaki sposób można zarabiać na aplikacji? W przeróżny taki jak:\n\n\n  sprzedaż danych o użytkowniku\n  kopanie kryptowaluty\n  mikropłatności\n\n\nNajłatwiejszym jednak środkiem zarabiania, jeśli przyjmiemy że głównym kryterium doboru jest zainwestowany czas w implementację okazują się reklamy. Jest to również często pierwsza myśl, gdy zaczynasz myśleć o jakiejkolwiek monetyzacji - czy to aplikacja webowa, czy mobilna. Pomimo faktu, że nikt ich nie lubi, to Polsat od lat korzysta z tego patentu i ma się całkiem nieźle. Podstawa to umiejętne nimi zarządzanie i używanie we właściwym momencie. Dlaczego akurat reklamy, a nie którakolwiek pozycja z powyższej listy?\n\n\n  Sprzedaż danych o użytkowniku wymaga abyś dane te gdzieś zbierał, przetwarzał i miał klienta który chętnie za nie zapłaci. Problemem jest fakt, że nie masz takiego klienta. No i wynalazek w stylu RODO mocno komplikuje cały proceder.\n  Kopanie kryptowaluty na telefonie użytkownika jest mało wydajne, zajeżdza baterię, a przede wszystkim jest mało etyczne - chyba, że go powiadomisz o tym fakcie, ale wtedy pewnie odinstaluje aplikację. Kto celowo chciałby dołączyć do farmy zombie?\n  Mikropłatości uważam za świetną strategię monetyzacyjną, jednak wpierw trzeba mieć na tyle dobry produkt, aby móc przekonać użytkownika do barteru twarda waluta -&amp;gt; wirtualne dobro. Myślisz że Twój aktualny produkt jest na tyle dobry, aby sprzedawać wirtualne złote monety komuś innemu niż mamie i tacie?\n\n\nMamy pełną jasność - zaczynamy od reklam. Reklama reklamie jednak nierówna, o czym przekonasz się w nieco dalszej części wpisu.\n\n\n\nZrozumieć reklamy\n\nWyświetlanie reklam w aplikacji mobilnej opiera się na udostępnianiu określonej przestrzeni ekranu reklamodawcy, który wstawi w to miejsce odpowiednią wizualizację. Zupełnie jak w świecie rzeczywisitym - reklamodawca wynajmuje przestrzeń reklamową np. bilboard przy drodze szybkiego ruchu i rozwiesza na nim swój plakat reklamujący nową Hondę, czy też firma, która wykupuje od pewnej stacji telewizyjnej czas antenowy, podczas którego zajmie ekran widza swoim krótkim spotem.\n\nWszystko fajnie, koncept jest stosunkowo jasny. Pozostaje jedynie kwestia znalezienia reklamodawcy, który zechciałby rozwiesić u nas swój “plakat reklamowy”. Nie musimy na szczęście szukać zainteresowanej firmy na własną rękę, dzięki czemu odpada nam konieczność implementacji własnego silnika reklamowego, rozliczeniowego i miliona innych zbędnych z punktu widzenia aplikacji funkcjonalności. Wystarczy wybrać jednego z istniejących dostawców reklam, zintegrować się z jego SDK i zacząć wyświetlać reklamy.\n\nDostawcy reklam (sieć reklamowa)\n\nWybrać dostawcę? Ale którego? Na rynku dostępne są dziesiątki dostawców - mniejszych i większych - spośród których można wybrać tego najlepszego. A najlepszy to ten, który płaci najwięcej za wyświetlenia. Nie tylko. Uwzględnijmy kilka pomniejszych kwestii które koniecznie należy mieć na uwadze:\n\n\n  Wypłacalność dostawcy. Szkoda byłoby zbierać wirtualne złotówki przez kilka miesięcy, a w momencie wypłaty dowiedzieć się, że nic się nie dzieje i nasze środki pozostaną wirtualne na wieki.\n  Istnieje szczegółowa dokumentacja opisująca proces integracyjny. Oszczędzi nam to czasu na osadzanie reklam metodą prób i błędów, gdzie nigdy nie mamy pewności że wszystko zrobiliśmy jak należy.\n  Dojrzałe i rozbudowane SDK. Takie które umożliwi nam wyświetlanie różnych rodzajów kreacji reklamowych (o tym za chwilę), czy możliwość sterowania dopasowaniem reklamy. Jeśli masz aplikację o tematyce motoryzacyjnej to dopasowana reklama będzie dotyczyć m.in. nowej Hondy, a nie leku na hemoroidy.\n  Fill rate, czyli duża ilość reklamodawców wewnątrz sieci. Dostawca nie osadza własnych reklam, lecz reklamy zlecone przez reklamodawców. Im większa liczba takich reklamodawców, tym większa szansa na to, że będziemy mieli jakąkolwiek reklamę do wyświetlenia. Co nam z tego, że dostawca płaci 3x więcej niż konkurencja, skoro reklamę wyświetlimy 1 na 100 użytkowników. Przykładowo Pepsi zleca kampanię reklamową przez AdMob, a AdMob zleca swoim partnerom (Tobie) wyświetlanie reklamy.\n\n\nKwestii tego typu jest zdecydowanie więcej, dlatego aby oszczędzić nam obojgu czasu przejdę już do sedna. Skorzystaj z AdMob. Jest to sieć reklamowa, której właścicielem jest Google (tak samo jak Fluttera), istnieje na rynku niemal od zawsze i jest rozwiązaniem, którego sam używam w swoich aplikacjach. Bardziej zarekomendować nie potrafię - Wszyscy mają AdMob - mam i ja.\n\nKonto w AdMob\n\nRozpoczęcie dowolnej integracji wymaga niemal zawsze utworzenia stosownego konta na platformie docelowej. Nie inaczej jest w przypadku AdMoba - konto wymagane, nic nie poradzisz. Proces jest prosty, niefinezyjny, nie warto nad nim dogłębnie rozpisywać - do brzegu!\n\n\n  Przejdź na stronę https://admob.google.com/home/ i kliknij w przycisk Sign up\n  Zaloguj się swoim kontem Google i wypełnij krótki formularz:\n    \n      Country or territory: Poland\n      Time zone: (UTC+01:00) Prague\n      Billing currency: Polish Zloty (PLN)\n      Zaakceptuj regulamin (po ewentualnym przeczytaniu)\n    \n  \n  Odpowiedz No na wszystkie pytania o spam mailing\n  Podaj numer telefonu w celu weryfikacji (preferuję SMS) - nie zostaną naliczone żadne koszty.\n  Konto w platformie utworzone, zostałeś partnerem.\n\n\nMasz już własne konto, ale to za mało. Musisz dodatkowo stworzyć nową aplikację z poziomu panelu administracyjnego. W tym celu z bocznego menu wybierz Aplikacje &amp;gt; Dodaj aplikację i postępuj zgodnie z krokami formularza. Podaj nazwę swojej aplikacji oraz docelową platformę. Zaraz, zaraz. Jak to platformę? Przecież aplikacja jest pisana we Flutterze, więc cross-platformowa i dostępna na obu. Oczywiście! W takim celu musisz stworzyć dwie osobne aplikacje w panelu - jedną dla Android, drugą dla iOS.\n\nPo podaniu podstawowych danych, możesz przejść do sekcji Jednostki reklamowe &amp;gt; Dodaj jednostkę reklamową, aby tworzyć tzw. jednostki reklamowe. Jest to jednak krok opcjonalny, na czas wpisu będziemy korzystali z ogólnodostępnych identyfikatorów testowych.\n\nJednostki reklamowe\n\nJednostka reklamowa to bezpośredni element, który osadzasz w aplikacji mobilnej. Każda jednostka posiada dwie podstawowe cechy: unikalny identyfikator oraz typ. Identyfikatora użyjesz w momencie wyświetlania reklamy, tak aby dostawca reklamowy wiedział, że to Ty osadzasz daną reklamę i należą Ci się za to pieniądze. Typ kreacji to taki enum, który przyjmuje jedną z trzech wartości: baner, reklama pełnoekranowa, reklama nagradzająca. O tym czym się różnią, jak i kiedy ich używać dowiesz się w kolejnej sekcji.\n\nPraktyka\n\nTeoria reklamowa za nami, pora przetestować je na żyjącym organizmie. Osadźmy błyszczący baner w aplikacji i zacznijmy zarabiać (nie)godziwe pieniądze! STOP. Pozostał jeszcze jeden krok aby móc eksperymentować z jednostkami reklamowymi - musimy przeprowadzić wstępną konfiguracjo-integrację:\n\nWstępna konfiguracja\n\n\n  W pliku pubspec.yaml dodaj nową zależność i zainstaluj ją:\n    dependencies:\n  firebase_admob: 0.9.0+1\n    \n  \n\n\nNie wiesz jak zainstalować dodaną zależność? W konsoli przejdź do katalogu projektu i wykonaj następującą komendę:\n\nflutter pub get\n\n\n\n  [Android] W pliku android/app/src/main/AndroidManifest.xml w obrębie węzła &amp;lt;application&amp;gt; dodaj informację o identyfikatorze aplikacji z AdMob. Zastąp [ADMOB_APP_ID] wartością z panelu AdMob, którą znajdziesz wybierając aplikację z listy i przechodząc do sekcji jej ustawień.\n\n\n&amp;lt;meta-data\n    android:name=&quot;com.google.android.gms.ads.APPLICATION_ID&quot;\n    android:value=&quot;[ADMOB_APP_ID]&quot; /&amp;gt;\n\n\n\n\nJeśli masz problem z poprawnym umiejscowieniem znacznika, lub nie masz pewności czy wstawiłeś go w odpowiednim miejscu - spójrz na przykładowy plik AndroidManifest.xml.\n\n\n  [iOS] W pliku ios/Runner/Info.plist dodaj nową parę klucz-wartość. Zastąp [ADMOB_APP_ID] wartością z panelu AdMob, którą znajdziesz w identyczny sposób jak w przypadku konfiguracji Androida.\n\n\n&amp;lt;key&amp;gt;GADApplicationIdentifier&amp;lt;/key&amp;gt;\n&amp;lt;string&amp;gt;[ADMOB_APP_ID]&amp;lt;/string&amp;gt;\n\n\nPrzykładowy plik Info.plist.\n\n\n  Pamiętaj aby podając identyfikatory aplikacji, platformy zgadzały się z tym co jest zapisane w panelu. Jeśli przykładowo w pliku AndroidManifest.xml podasz klucz pasujący do platformy iOS to aplikacja może przestać się uruchamiać.\n\n\n\n  Przed rozpoczęciem osadzania reklam musisz koniecznie zainicjalizować klienta reklamowego. Najprościej jest to zrobić wewnątrz metody main w pliku lib/main.dart.\n\n\nimport &#39;dart:io&#39; show Platform;\nimport &#39;package:flutter/material.dart&#39;;\nimport &#39;package:firebase_admob/firebase_admob.dart&#39;;\n\nconst ANDROID_KEY = &quot;[ANDROID_KEY]&quot;;\nconst IOS_KEY = &quot;[IOS_KEY]&quot;;\n\nvoid main() {\n  String appId = Platform.isAndroid ? ANDROID_KEY : IOS_KEY;\n  FirebaseAdMob.instance.initialize(appId: appId);\n  \n  runApp(App());\n}\n\n// ...\n\n\nGdzie [ANDROID_KEY] i [IOS_KEY] muszą zostać podmienione na identyczne wartości jakich użyłeś odpowiednio w plikach AndroidManifest.xml i Info.plist. Przykładowy main.dart.\n\nJeśli chodzi o wstępną konfigurację - mamy to. Jesteśmy teraz w pełni przygotowani, aby wskoczyć do kodu Fluttera i rozpocząć pisanie aplikacji demonstracyjno-reklamowej.\n\nLayout aplikacji\n\nLayout aplikacji będzie się składać początkowo z trzech przycisków, gdzie każdy jest odpowiedzialny za wyświetlenie reklamowy odpowiedniego typu. Żadego fancy stylowania, surowy widok umożliwiający nam rozegranie partii z reklamami.\n\nclass App extends StatefulWidget {\n  @override\n  _AppState createState() =&amp;gt; _AppState();\n}\n\nclass _AppState extends State&amp;lt;App&amp;gt; {\n  void showBanner() {}\n  void showInterstitial() {}\n  void showRewardVideo() {}\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: &#39;AdMob demo&#39;,\n      home: Scaffold(\n        body: Center(\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              RaisedButton(\n                child: Text(&quot;Show banner&quot;),\n                onPressed: showBanner,\n              ),\n              RaisedButton(\n                child: Text(&quot;Show interstitial&quot;),\n                onPressed: showInterstitial,\n              ),\n              RaisedButton(\n                child: Text(&quot;Show reward video&quot;),\n                onPressed: showRewardVideo,\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\nApp od samego początku implementowany jest jako widget stanowy - czuję wiem, że im dalej w las tym bardziej będziemy potrzebowali zarządzać stanem. Jeśli chodzi o sam layout to jest on prosty w opór. Trzy przyciski na środku ekranu wołające powiązane funkcje, które aktualnie nic nie robią. A skoro nic nie robią to na pewno nie wyświetlają też reklam. Jeszcze!\n\n\n\nWyświetlanie reklam\n\nWyświetlanie reklamy - nie zależnie od jej typu - zawsze opiera się o identyczny scenariusz jeśli chodzi o implementację. Różnią się szczegóły, detale takie jak kiedy dokładnie pokażemy reklamę. To jednak problem czysto UX. Od strony kodu wyróżniamy dwa główne kroki do osiągnięcia celu:\n\n\n  Załadowanie reklamy (load) - pierwszą rzeczą jaką musimy zrobić jest wysłanie żądania do reklamodawcy (AdMob), żeby dostarczył nam kreację określonego typu. Wołamy reklamodawcę i informujemy go, że w niedługim czasie będziemy chcieli pokazać przykładowo baner i niech nam dostarczy odpowiednią wizualizację. Operacja albo się uda, albo i nie. Od czego zależy sukces? Przede wszystkim od dostępności połączenia z internetem (nie ma internetu, nie ma reklam) oraz fill rate, który omawialiśmy wyżej.\n  Wyświetlenie reklamy (show) - gdy reklama zostanie poprawnie załadowana nie jest automatycznie prezentowana na ekranie. Musimy sami podjąć kolejną akcję, aby pokazać ją użytkownikowi. Jest to akcja typu “czysta formalność” - konkretna kreacja zostałą już zaciągnięta na telefon użytkownika i oczekuje jedynie sygnału do zmaterializowania się na ekranie.\n\n\nBaner (Banner)\n\nBaner reklamowy, czyli pasek na pełną szerokość ekranu i określoną wysokość (32, 50, lub 90 pikseli). Wyświetlany najczęśćiej na samym dole aplikacji. Z punktu widzenia osadzania tej jednostki reklamowej - najprościej jest zlecić dobranie rozmiaru SDK, tak aby określiło odpowiednią wysokość banera (smart size). Brana jest pod uwagę w tym wypadku rozdzielczość ekranu, tak aby pomimo stale wyświetlanej reklamy zapewnić jak największy komfort użytkowania. Jeśli masz własną wizję lub nietypowy design wymagający określonego banera to możesz to prosto skonfigurować pod własne potrzeby. Jednostka charakteryzuje się łatwością osadzenia - przy starcie aplikacji wystarczy załadować reklamę i ją wyświetlić. Sama będzie zmieniała swoją zawartośc co określony interwał (rotacja reklamy), a my nie musimy się martwić niczym więcej.\n\n\n\nW aplikacji przyjęliśmy wstępny scenariusz, że to użytkownik klika w przycisk, aby zobaczyć baner reklamowy. Tak też zróbmy poprzez odpowiednią implementację powiązanej metody:\n\nvoid showBanner() async {\n  var banner = BannerAd(\n    adUnitId: BannerAd.testAdUnitId,\n    targetingInfo: MobileAdTargetingInfo(),\n    size: AdSize.smartBanner,\n  );\n  banner.listener = (MobileAdEvent event) {\n    if (event == MobileAdEvent.loaded) {\n      banner.show();\n    }\n  };\n  banner.load();\n}\n\n\nSporo się tutaj dzieje jak na pierwszy raz - tak przynajmniej to wygląda. W rzeczywistości to żaden rocket science!.\n\nvar banner = BannerAd(\n  adUnitId: BannerAd.testAdUnitId,\n  targetingInfo: MobileAdTargetingInfo(),\n  size: AdSize.smartBanner,\n);\n\n\nTworzymy nową instancję typu BannerAd, czyli baner reklamowy. Interesujące są argumenty które dostarczamy:\n\n\n  adUnitId to identyfikator jednostki reklamowej do wyświetlenia. Najważniejszy z parametrów, bo to on odpowiada czy wyświetlasz swoją reklamę za którą masz płacone, czy np. sąsiada z bloku obok (też jest programistą?). Aktualna wersja kodu wykorzystuje zdefiniowaną stałą, która wyświetli baner testowy (bezpieczny, bo można go klikać do woli bez ryzyka zbanowania).\n  targetingInfo pozwala na określenie dodatkowych wytycznych odnośnie samej reklamy, zawężenie grupy odbiorców. Możemy zdefiniować, że aplikacji używają głównie dzieci i dostaniemy reklamy wyłącznie z określonej puli. Możemy także podać listę słów kluczowych, które wiemy że pasują do obecnego użytkownika, aby zaprezentować mu lepiej dopasowaną reklamę. WIN-WIN. Ewentualnie nie definiować nic (co też robimy) - Google i tak wie wiele o użytkowniku z własnych źródeł.\n  size określa jak się spodziewasz rozmiar reklamy. Z własnego doświadczenia polecam zawsze korzystać z AdSize.smartBanner, szkoda czasu i życia na zastanawianie się samemu jaki rozmiar dobrać, aby był adekwatny do urządzenia użytkownika. Parametr występuje tylko na reklamach typu baner.\n\n\nbanner.listener = (MobileAdEvent event) {\n  if (event == MobileAdEvent.loaded) {\n    banner.show();\n  }\n};\n\n\nRozpoczynamy nasłuchiwanie na wszelkie zdarzenia które przytrafią się naszemu nowo utworzonemu banerowi. Z praktycznego punktu widzenia interesuje nas jeden konkretny - MobileAdEvent.loaded - który otrzymamy, gdy tylko reklama zostanie poprawnie załadowana na urządzenie. W tym momencie chcemy zrobić już tylko jedną rzecz - pokazać reklamę na ekranie. PROFIT.\n\nbanner.load();\n\n\nRozpoczęcie procesu ładowania reklamy. Nie dostarczamy tutaj żadnych argumentów - wszystkie istotne dane zostały już określone w momencie konstruowania instancji banera. Cała obsługa tego co dzieje się podczas/po załadowaniu wizualizacji odbywa się bezpośrednio w listenerze zdefiniowanym wyżej.\n\nUruchom aplikację i stuknij w przycisk Show banner. Początkowo nic się nie zadzieje, jednak po maksymalnie paru sekundach zobaczysz na dole ekranu baner z reklamą testową. Sukces! Jedyny problem jaki pozostał do rozwiązania to nienaturalność. Baner jest najczęściej ładowany i pokazywany tuż po uruchomieniu aplikacji - użytkownik nie podejmuje żadnej akcji z tym związanej. Wyrzućmy dedykowany przycisk, a funkcję showBanner zawołajmy bezpośrednio w metodzie initState, aby baner pokazał się tak szybko jak to tylko możliwe.\n\nclass _AppState extends State&amp;lt;App&amp;gt; {\n  @override\n  void initState() {\n    showBanner();\n    super.initState();\n  }\n  // ...\n}\n\n\n\n  SDK umożliwia pokazanie kilku banerów na jednym ekranie (np. góra+dół), jednak jest to niezgodne z polityką AdMob. Nie rób tego, jeśli nie chcesz zostać zbanowany razem ze zgromadzonymi środkami. Pamiętaj - w jednym czasie na ekranie może być widoczny tylko jeden baner!\n\n\nReklama pełnoekranowa (Interstitial)\n\nWariant pełnoekranowego modala całkowicie przykrywającego zawartość aplikacji. W przeciwieństwie do banera nie jest widoczny przez cały czas i to od Ciebie zależy kiedy go pokażesz - lepiej nie na starcie aplikacji bo cuchnie to tandetą i skutkuje błyskawicznym odinstalowaniem aplikacji z telefonu. Idealnym momentem są za to tzw. przerywniki. Moment w którym kończy się pewien proces/etap jak np. przejście poziomu w grze, czy odznaczenie wszystkich pozycji na wirtualnej liście jako ukończone. Wszystko zależy od konkretnej aplikacji i znalezienia złotego (ewentualnie srebrnego) punktu w którym można się wpasować z reklamą.\n\n\n\nWarto pamiętać o tym, że lepiej pokazać reklamę użytkownikowi zadowolonemu, niż sfrustrowanemu. Stoi za tym prosty powód i wytłumaczenie. Obejrzenie reklamy obniża poziom ogólnie przyjętego szczęścia, jakakolwiek by ona nie była. Nikt nie lubi reklam. Jeśli więc postanowiłeś, że pokażesz reklamę użytkownikowi za każdym razem gdy błędnie wypełni formularz - przemyśl to. Przeleje się czara goryczy, a użytkownik wystawi Ci niepochlebną opinię w sklepie i odinstaluję aplikację na wieki wieków. Amen.\n\nAnalogicznie jak w przypadku banera - chcemy zaprezentować reklamę użytkownikowi po stuknięciu w przycisk. Tym razem jednak zamiast małego banera, wyświetlimy pełnoekranową jednostkę która zasłoni cały dotychczasowy widok.\n\nvoid showInterstitial() {\n  var interstitial = InterstitialAd(\n    adUnitId: InterstitialAd.testAdUnitId,\n    targetingInfo: MobileAdTargetingInfo(),\n  );\n  interstitial.listener = (MobileAdEvent event) {\n    if (event == MobileAdEvent.loaded) {\n      interstitial.show();\n    }\n  };\n  interstitial.load();\n}\n\n\nKod wygląda jakby znajomo prawda? To niemal kalka z funkcji showBanner! Tworzymy instancję reklamy InterstitialAd, zaczynamy nasłuchiwać zdarzeń i wysyłamy żądanie ładowania. Nic co warte byłoby dodatkowego opisu. Główna różnica polega na tym, że nie definiujemy rozmiaru kreacji. Dlaczego? Bo reklama pełnoekranowa jest pełnoekranowa aka zajmuje pełną dostępną przestrzeń ekranu. Obvious.\n\nWstępna implementacja gotowa. Kliknięcie w przycisk rozpoczyna ładowanie reklamy, po czym automatycznie pojawia się na ekranie. Niby fajnie, ale znowu - nie życiowo. Nie planuję komplikować oczywiście naszej aplikacji, aby użycie kreacji tego typu miało 100% sens, jednak szczypta zmian jest mile widziana. Pamiętasz kiedy jest dobry moment na pokazanie reklamy pełnoekranowej? Gdy użytkownik zamyka pewien proces np. wygrywa kolejny poziom w grze.\n\nZasymulujmy w opór prostą grę, która będzie polegała na wyborze z dostępnych kwadratów tego który ma kolor czerwony. Wiem, wiem - brzmi głupio, ale lepiej obrazuje sposób wykorzystania reklamy tego typu. Zastąp przycisk pokazujący reklamę następującym kodem, który wyświetli 4 kwadraty zielone i 1 czerwony. Kliknięcie na czerwony oznacza zwycięstwo i przejście na kolejny poziom + reklama.\n\nRow(\n  mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n  children: boxes,\n)\n\n\nDostępne kwadraty trzymane są w stanie aplikacji, aby w momencie przejścia na kolejny poziom móc je zaktualizować. Zainicjalizujmy wstępnie listę wartościami.\n\nclass _AppState extends State&amp;lt;App&amp;gt; {\n  List&amp;lt;Widget&amp;gt; boxes = [];\n  \n  @override\n  void initState() {\n    boxes = getInitialBoxes();\n    // ...\n  }\n  \n  List&amp;lt;Widget&amp;gt; getInitialBoxes() {\n    return [\n      Container(width: 50, height: 50, color: Colors.green),\n      Container(width: 50, height: 50, color: Colors.green),\n      GestureDetector(\n        child: Container(width: 50, height: 50, color: Colors.red),\n        onTap: showInterstitial,\n      ),\n      Container(width: 50, height: 50, color: Colors.green),\n      Container(width: 50, height: 50, color: Colors.green),\n    ];\n  }\n}\n\n\n\n\nTo jednak nie wszystko. Chcemy też mieć pewność kiedy dokładnie wyświetli się reklama - z dokładnością do teraz, a nie za sekundę-dwie. Aby to osiągnąć musimy załadować reklamę na początku gry, a w odpowiednim czasie jedynie ją wyświetlić. Wymaga to trochę zmian w kodzie aplikacji. Po pierwsze załadujmy reklamę na samym starcie, jednak bez listenera który pokaże ją gdy tylko będzie dostępna.\n\nclass _AppState extends State&amp;lt;App&amp;gt; {\n  InterstitialAd interstitial;\n  \n  @override\n  void initState() {\n    interstitial = InterstitialAd(\n      adUnitId: InterstitialAd.testAdUnitId,\n      targetingInfo: MobileAdTargetingInfo(),\n    );\n    interstitial.load();\n    // ...\n  }\n}\n\n\nDodatkowo niezbędna jest zmiana funkcji showInterstitial, aby nie tworzyła obiektu reklamy do załadowania - kroki te zostały już wykonane na starcie. Jedyna odpowiedzialność tej funkcji to wyświetlenie reklamy. Po pokazaniu reklamy chcemy również wygenerować nową planszę w sposób pseudolosowy. Brzmi fancy, w rzeczywistości ograniczymy się do przetasowania elementów - nie gwarantujemy, że po przetasowaniu nie trafimy znowu na ten sam rozkład.\n\nvoid showInterstitial() {\n  setState(() {\n    boxes.shuffle();\n  });\n  interstitial.show();\n}\n\n\nUruchom aplikację ponownie i wciel się w rolę gracza. Przez “wciel się” mam na myśli fakt, abyś udawał że zastanawiasz się który z kwadratów jest czerwony (chyba że poważnie masz z tym problem) - daj czas reklamie na załadowanie się w tle. Wybierz odpowiedni kwadracik i gotowe - reklama wyskakuje zanim zdążysz mrugnąć. Świetnie, ale co z graczem który od razu kliknie w dobry kwadracik? Nic. Z reguły proces podczas którego ładujesz reklamę jest dłuższy niż czas potrzebny na jej załadowanie - wyimaginowany problem. A nawet jeśli się zdarzy to najłatwiej się z tym po prostu pogodzić - czasem użytkownik nie zobaczy reklamy. Jest to zdecydowanie lepsze rozwiązanie niż blokowanie możliwości przejścia procesu póki nie będziesz miał gotowej reklamy.\n\nJeśli przy testowaniu byłeś odpowiednio ciekawski to zauważyłeś prawdopodobnie pewien intrygujący fakt. Pierwsze zwycięstwo rzeczywiście wyświetla reklamę, jednak po jej zamknięciu i ponownej wygranej nic się dzieje. Brak reklamy to brak profitu. Dlaczego działa tylko w pierwszej próbie? Powód jest prozaiczny. Reklamę tworzysz i ładujesz tylko raz przy starcie. Jeśli pokażesz ją użytkownikowi to koniec, nie ma więcej. Nie możesz pokazać dwa razy tej samej załadowanej kreacji.\n\nRozwiązaniem jest obsłużenie zdarzenia zamknięcia reklamy i utworzenie w tym momencie nowej instancji reklamowej. W takim przypadku pokażesz użytkownikowi aktualną reklamę, a tuż po zamknięciu zaczniesz ładować kolejną kreacją na przyszłość. Proste i błyskotliwe - takie rozwiązania lubię i polecam. Wymaga to jednak drobnego refaktoringu, gdyż nie mamy teraz dedykowanej funkcji która re-inicjalizuje obiekt InterstitialAd. W obrębie initState zastąp cały kod operujący na obiekcie interstitial wywołaniem funkcji loadInterstitial.\n\n@override\nvoid initState() {\n  loadInterstitial();\n  // ...\n}\n\nvoid loadInterstitial() {\n  interstitial = InterstitialAd(\n    adUnitId: InterstitialAd.testAdUnitId,\n    targetingInfo: MobileAdTargetingInfo(),\n  );\n  interstitial.listener = (MobileAdEvent event) {\n    if (event == MobileAdEvent.closed) {\n      loadInterstitial();\n    }\n  };\n  interstitial.load();\n}\n\n\nReklama nagradzająca (Rewarded video)\n\nBrat bliźniak reklamy pełnoekranowej jeśli chodzi o formę prezentacji - zasłania cały ekran szukając atencji. Główna różnica polega na wyczuciu momentu w którym chcemy ją zaprezentować użytkownikowi. Bo o ile forma jest niemal identyczna, to intencja diametralnie się różni i należy być ostrożnym w jej używaniu. Jak nazwa sugeruje ma ona coś wspólnego z nagradzaniem użytkownika. Powstaje, więc transakcja wiązana: Ty dostajesz pieniądze za wyświetlenie, a użytkownik dostaje … No właśnie, co?\n\nTo zależy. Od aplikacji. Od tego co jest w stanie zaoferować użytkownikowi w zamian za obejrzenie reklamy. Dodatkowe życie? Wirtualne złote monety? Czasowe odblokowanie pewnych funkcjonalności? Każda odpowiedź jest dobra. Musisz jedynie zaprojektować swój interfejs w taki sposób, aby użytkownik świadomie uruchomił reklamę tego typu i wiedział jaka czeka go nagroda za w pełni obejrzaną reklamę (z reguły trwają 30 sekund). SDK poinformuje Cię, czy użytkownik obejrzał reklamę w całości, czy też przerwał ją w trakcie (a wtedy nie dasz mu nagrody).\n\n\n\nMamy już doświadczenie z osadzaniem reklamy pełnoekranowej, tutaj implementacja będzie bardziej niż zbliżona.\n\n@override\nvoid initState() {\n  loadRewardVideo();\n  // ...\n}\n\nvoid loadRewardVideo() {\n  RewardedVideoAd.instance.listener = (RewardedVideoAdEvent event, {String rewardType, int rewardAmount}) {\n    if (event == RewardedVideoAdEvent.closed) {\n      loadRewardVideo();\n    }\n  };\n  RewardedVideoAd.instance.load(\n    adUnitId: RewardedVideoAd.testAdUnitId,\n    targetingInfo: MobileAdTargetingInfo(),\n  );\n}\n\nvoid showRewardVideo() {\n  RewardedVideoAd.instance.show();\n}\n\n\nKod wygląda niemal identycznie jak w przypadku reklamy pełnoekranowej, a główna różnica polega na tym, że sami nie tworzymy instancji obiektu reklamowego. RewardedVideoAd udostępnia swoją instancję jako singleton poprzez RewardedVideoAd.instance. Jest to zabieg projektowy uniemożliwiający nam ładowania w jednym czasie więcej niż 1 reklamy nagradzającej. Not a big deal.\n\nDrugą ważną, a nawet ważniejszą rzeczą niż singletonowy interfejs jest nietypowy listener. Przyjmuje on co prawda obiekt zdarzenia (nuda), ale pojawiają się też dwa nowe parametry:\n\n\n  rewardType - rodzaj nagrody w postaci ciągu znaków, którą otrzyma użytkownik po obejrzeniu reklamy (np. monety).\n  rewardAmount - wartość/kwota nagrody w postaci liczby całkowitej, którą nagrodzisz użytkownika (np. 10).\n\n\nSkąd pochodzą te wartości? Definiujesz je w momencie tworzenia nowej jednostki reklamowej z poziomu panelu administracyjnego AdMob. To od Ciebie zależy jakie wartości przyjmą i co z nimi zrobisz. W przykładzie korzystamy z RewardedVideoAd.testAdUnitId, który definiuje rodzaj nagrody jako coins o wartości równej 10 - czyli 10 wirtualnych monet za obejrzenie reklamy.\n\n\n\nReklama poprawnie wyświetla się na ekranie, pora do domu …\n\n\n\n… nie tak szybko. Pamiętasz definicję tej jednostki reklamowej? Transakcja wiązana, nagroda dla obu stron. Póki co Ty masz nagrodę, bo reklama została obejrzana, ale co z biednym użytkownikiem? Jego czas jest bezwartościowy bezcenny! Naprawmy nasz błąd, wprowadzając do gry bezcenne bezwartościowe monety, które można pozyskać na dwa sposoby:\n\n\n  Przejście poziomu w grze daje użytkownikowi 1 monetę.\n  Obejrzenie reklamy daje monet 10. Taki Pay-to-win nam wyszedł, a raczej Watch-to-win.\n\n\nBalans na bok, czas na wirtualną pseudowalutę! Na początku gry balans gracza to 0 monet.\n\nclass _AppState extends State&amp;lt;App&amp;gt; {\n  int coins = 0;\n  \n  // ...\n\n\nPrzejście pojedynczego poziomu nagradza 1 monetą …\n\nvoid showInterstitial() async {\n  setState(() {\n    coins++;\n    boxes.shuffle();\n  });\n  // ...\n}\n\n\n… a objerzenie reklamy rozbija bank w postaci 10 monet.\n\nvoid loadRewardVideo() {\n    RewardedVideoAd.instance.listener =\n        (RewardedVideoAdEvent event, {String rewardType, int rewardAmount}) {\n      // ...\n      if (event == RewardedVideoAdEvent.completed) {\n        setState(() {\n          coins += rewardAmount;\n        });\n      }\n    };\n    // ...\n  }\n\n\nPozostała jedynie kwestia wyświetlenia aktualnego salda monetowego, aby użytkownik mógł śledzić swój majątek i jego ciągły przyrost. Dodaj nowy widget do Column z prostym tekstem.\n\nchildren: [\n  Text(&quot;Coins: $coins&quot;),\n  // ...\n]\n\n\nOstatnią rzeczą którą warto zrobić jest zmiana tekstu na przycisku wyświetlającym reklamę z Show reward video na Get FREE coins, lub coś równie wymownego. Nikt nie lubi reklam, ale każdy lubi darmowe fanty 💰.\n\nReklamy produkcyjne\n\nWyświetlanie reklam testowych zadziałało bezbłędnie, ale w prawdziwej aplikacji zdecydowanie wolałbyś wyświetlać własne jednostki. W tym celu należy podmienić wystąpienia xyzAd.testAdUnitId na własne identyfikatory reklamowe wygenerowane w panelu AdMob.\n\n\n  Przejdź na stronę https://admob.google.com/home/ i zaloguj się.\n  Z sekcji Aplikacje wybierz aplikację dla której chcesz utworzyć jednostki reklamowe.\n  Z bocznego menu przejdź do sekcji Jednostki reklamowe i kliknij przycisk Zacznij teraz\n\n\n\n\n\n  Wybierz typ jednostki którą chcesz utworzyć (Zaawansowane reklamy natywne nie są jeszcze wspierane we Flutterze)\n\n\n\n\n\n  Podaj nazwę jednostki, która będzie widoczna tylko dla Ciebie w panelu np. [Android] testApp banner\n  Skopiuj identyfikator reklamowy i użyj go przy inicjalizacji odpowiedniej jednostki reklamowej na danej platformie.\n\n\n\n\n\n  Powtórz czynność dla wszystkich platform/jednostek które chcesz wspierać w aplikacji.\n\n\n\n  W przypadku gdy w konsoli pojawiają się błędy typu failedToLoad - odczekaj godzinę, dwie, aż nowo utworzona jednostka będzie poprawnie rozpoznawana przez systemy reklamodawcy. Cierpliwość popłaca.\n\n\nPodsumowanie\n\nMasz teraz mocne i solidne podstawy - zarówno teoretyczne jak i praktyczne - dotyczące monetyzacji przez reklamy. Nie ma żadnych przeciwwskazań, abyś wybrał innego dostawcę reklam pod warunkiem, że istnieje stabilna paczka pod Fluttera. Pełny kod aplikacji reklamowej znajdziesz na GitHubie.\n"
} ,
  
  {
    "title"    : "Zarządzanie stanem aplikacji - StatefulWidget",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-state-management-stateful/",
    "date"     : "July 5, 2019",
    "excerpt"  : "Aplikacje mobilne - a także webowe, czy desktopowe - nie opierają się wyłącznie na statycznych kontrolkach, które widzi nasz użytkownik. Aplikacja to nie tylko zbiór obrazków, przycisków i list, zawsze jest coś więcej. W przeciwnym wypadku zbudowa...",
  "content"  : "Aplikacje mobilne - a także webowe, czy desktopowe - nie opierają się wyłącznie na statycznych kontrolkach, które widzi nasz użytkownik. Aplikacja to nie tylko zbiór obrazków, przycisków i list, zawsze jest coś więcej. W przeciwnym wypadku zbudowaliśmy wydmuszkę której jedynym zadaniem jest jej podziwianie - dzieło sztuki, nieprawdaż?\n\nNie ma znaczenia na jaką platformę budujemy nasz program - zawsze potrzebujemy interakcji ze strony użytkownika. Skupmy się jednak na wersji mobilnej. Jakie przykładowe akcje mogą zajść w aplikacji na które musimy odpowiednio zareagować?\n\n\n  oznaczenie elementu jako ulubiony\n  dodanie przedmiotu do koszyka\n  stuknięcie w ikonkę koszyka\n\n\nKażda z tych akcji, wymaga odpowiedniej reakcji po stronie naszego kodu. Musimy przykładowo zaprezentować użytkownikowi co ma w koszyku, ale żeby tego dokonać potrzebujemy … tak - informacji o stanie koszyka (co w nim właściwie jest). Możemy także żonglować ulubionymi produktami, aby łatwiej móc je odnaleźć w przyszłości. Wszystkie wymienione funkcjonalności łączy część wspólna - operują na danych (stanie) aplikacji w trakcie jej działania.\n\n\n\nStan aplikacji\n\nStanem aplikacji nazywamy taki zestaw danych, który spełnia następujące kryteria:\n\n  odczyt danych dostępny jest w sposób synchroniczny podczas budowania widgetu (metoda build).\n  dane mogą (ale nie muszą) zmieniać się w trakcie trwania programu.\n\n\nJeśli masz doświadczenie z backendem (np. API) w aplikacjach webowych, to tam również operujesz na stanie. Nazywa się co prawda bardziej formalnie - baza danych - ale chodzi podobny koncept. Przechowujesz w niej dane, które od czasu do czasu się zmieniają i korzystasz z nich, aby odpowiadać aplikacji mobilnej na przesłane żądania (np. zwracając listę wszystkich zamówień użytkownika).\n\nI tyle? To ten szumny stan aplikacji? W skrócie to tak, trudno się bardziej nad nim rozpisywać - formułka oddaje całość tego czym jest. Bardziej złożonym problemem jest jednak to w jaki sposób nim zarządzać, ale o tym dowiesz się już za chwilę.\n\nZarządzanie stanem\n\nSkoro stan aplikacji oznacza zbiór danych używanych podczas działania programu, to zarządzanie stanem odnosi się do manipulacji tymi danymi i reagowaniem w interfejsie na te zmiany. Przykładowo poprzez usunięcie danej pozycji z koszyka, gdy użytkownik tapnie w ikonkę ❌ obok jej nazwy. Jako że mam podłoże mocno backendowe, to często utożsamiam akcje na stanie jako typowy CRUD (Create Read Update Delete):\n\n\n  Odczyt danych (wyświetlenie wszystkich pozycji w koszyku)\n  Dodawanie nowych danych (dodanie nowego produktu do koszyka)\n  Modyfikacja istniejących rekordów (zmiana ilości danego produktu w koszyku)\n  Usuwanie zbędnych wpisów (usunięcie produktu z koszyka)\n\n\nKażda z tych akcji (poza odczytem) zmienia dane, które trzymamy w stanie. Pamiętaj - zmienia dane, ale nie modyfikuje BEZPOŚREDNIO elementów wyświetlanych na ekranie. Funkcja uruchamiana w celu usunięcia pozycji z koszyka, aktualizuje tylko stan aplikacji i nic więcej. Nie odpowiada za to, żeby listing koszyka się magicznie odświeżył i usunął z ekranu stary element. Programowanie wokół stanu, a nie bezpośrednio na UI nazywamy programowaniem deklaratywnym.\n\nDeklaratywny vs imperatywny\n\nTrudne słowa, które w rzeczywistości łatwo jest zrozumieć. Osobiście sporo czasu pisałem w sposób deklaratywny, a jeszcze więcej w imperatywny, a dopiero dwa lata temu dowiedziałem się o istnieniu tych dwóch pojęć. Chodzi o sposób w jaki programujemy nasz interfejs użytkownika - o to jak wygląda początkowo (po uruchomieniu aplikacji) i jak zmienia się w trakcie działania.\n\nStyl imperatywny\n\nStyl imperatywny dotyczy przede wszystkim starszych technologii - Android SDK, czy iOS UIKit. Nie mam z nimi większego komercyjnego doświadczenia, dlatego posłużę się przykładem z aplikacji webowych i technologią jQuery. Niegdyś brylująca technologia do tworzenia aplikacji, dzisiaj leciwy i schorowany dziad(ek). Nie jesteśmy tu jednak żeby wspominać historię, czy wgłębiać się w wady i zalety jQuery, a zrozumieć imperatywny UI. Spójrzmy więc na prosty przykład, który łatwo zrozumieć nawet bez znajomości tej biblioteki:\n\n$(&quot;input.name&quot;).on(&quot;change&quot;, function() {\n  const name = $(this).val();\n  $(&quot;.greeting&quot;).text(&quot;Witaj &quot; + name);\n});\n\n\nNasłuchujemy eventu change na polu tekstowym name i gdy on nastąpi - aktualizujemy komponent greeting o nową wartość tekstową np. “Witaj Kamil”. Rozsądne i eleganckie rozwiązanie, prawda? TAK NIE. O ile trudno odmówić prostoty, to mamy tutaj co najmniej dwa problemy:\n\n\n  Jeśli jakikolwiek inny komponent w aplikacji chciałby również się aktualizować po zmianie imienia to musimy rozszerzyć naszą funkcję (fuj), lub w innym miejscu w kodzie również wpiąć się w ten sam event (genialne). Co jednak zrobisz, gdy w pewnym momencie okaże się, że imię można zmieniać w inny sposób niż początkowy input.name? Tak - zaktualizujesz 100 miejsc w aplikacji (nikt tego nie lubi).\n  Debugowanie jest tak trudne jak granie w Diablo 2 w trybie hardcore (no wiesz - permanentna śmierć). Im większa aplikacja, tym więcej się dzieje i w pewnym momencie nie potrafisz odpowiedzieć na pytanie kolegi z działu QA - “Dlaczego ten przycisk jest zablokowany?” (swoją drogą - autentyk). Wchodzisz do kodu, odnajdujesz stosowny przycisk, ale nie ma on w swojej deklaracji nic o blokowaniu. To czy jest zablokowany, czy też nie jest wysterowane przez 50 funkcji, które żonglują jego dostępnością.\n\n\nPodsumowując - styl imperatywny jest łatwy w zrozumieniu (“zmieniam imię to zmienia się nagłówek”), ale niesie ze sobą burdel w kodzie, szczególnie gdy aplikacja się rozrasta i dochodzą nowe funkcjonalności. W pewnym momencie utrzymanie takiego stwora staje się problematyczne i czasochłonne - acz możliwe. Na rynku mamy miliony aplikacji napisanych w taki sposób - nie twierdzę bynajmniej że to coś nierealnego.\n\nStyl deklaratywny\n\nNowy nurt w tworzeniu interfejsu użytkownika, który zakłada, że my jako programiści nie musimy przejmować się tym, aby konkretny element na ekranie zmienił swoje właściwości (kolor, tekst, cokolwiek) po zadziałaniu się akcji X. Naszym zadaniem jest natomiast stworzenie komponentów (widgetów), które w zależności od otrzymanego stanu mogą zmienić swój “wizerunek”. Jest to styl wykorzystywany przez takie technologie jak Swift UI, React, a także rzecz jasna Flutter.\n\nA teraz podejdźmy do tego bardziej łopatologicznie na pseudo-przykładzie (pamiętaj - to jest pseudokod, nie używaj go w domu):\n\nRaisedButton(\n  onPressed: () =&amp;gt; { clickCount++ },\n  child: Text(&quot;Kliki: ${clickCount}&quot;),\n)\n// ...\nText(clickCount &amp;lt; 10 ? &quot;Za klikanie jest nagroda.&quot; : &quot;Żartowałem :)&quot;)\n\n\nMamy tutaj przycisk, który po tapnięciu zwiększa wartość zmiennej clickCount, a dodatkowo wyświetla jej aktualny stan jako tekst. Dalej w drzewie umieściliśmy dodatkowy tekst, który w zależności od wspomnianego stanu zmienia prezentowaną formę.\n\nJak widzisz w funkcji onPressed nie zmieniamy ani tekstu na przycisku, ani tego na dole drzewa. Aktualizujemy wyłącznie stan aplikacji, a Flutter sam zajmie się resztą. Automatycznie rozwiązują nam się problemy stylu imperatywnego:\n\n\n  Stan jest jedynym źródłem prawdy, które każdy komponent może odczytać w dowolnym momencie. Nie ma znaczenia kiedy i jaka akcja zmieni stan - nasz UI odświeży się samoczynnie.\n  Ponownie - tylko stan aplikacji określa obecny UI. Wystarczy znaleźć zbugowany komponent i określić jaki stan musi zajść, aby przycisk się zablokował.\n\n\nW zależności od Twoich poprzednich doświadczeń - albo już to zaakceptowałeś i czujesz się w domu, albo będziesz potrzebował trochę czasu aby przestawić swój proces myślowy na nowe tory. Z własnego doświadczenia (a naprawdę długo pisałem imperatywnie) powiem, że WARTO.\n\nJeśli chciałbym w jednym zdaniu podsumować styl deklaratywny to byłaba to następująca fraza:\n\n\n  UI aplikacji budowany jest w celu zaprezentowania aktualnie posiadanego stanu.\n\n\nPokeTap\n\nDość teorii, daj praktykę! Najłatwiej uczyć się i walidować zdobytą wiedzę na przykładach, tak też zrobimy w tym przypadku. Nie lubię jednak demonstrować czegokolwiek na kolejnej aplikacji typu lista TODO. Możliwe że to niezdiagnozowane uczulenie, a może po prostu jest w sieci zbyt wiele rozwiązań tego typu i gdy widzę że będę poznawał nowe zagadnienie przez “listę rzeczy do zrobienia” to dopada mnie nagły atak spawacza mini-migreny.\n\nCo więc proponuję? GRĘ! Duże (bo drukowane) słowo na mały projekt, ale stworzymy prostego clickera limitowanego czasem. Nie będzie miał zbyt wiele polotu, ale na pewno będziemy się przy nim lepiej bawili niż wiesz przy czym (⬆️), a dodatkowo opanujemy niezbędne techniki zarządzania stanem. Poniżej możesz zerknąć na nasz docelowy design, który będzie nam towarzyszył przez resztę wpisu.\n\n\n\nGra polega na klikanie w przycisk Trenuj tak wiele razy jak to możliwe w ciągu limitowanego czasu 60 sekund. Każdy klik zwiększa nasz poziom oraz atrybuty ataku i obrony. Typowy grind, ale bez endgame. Zaczynajmy!\n\nSzybki prototyp (StatelessWidget)\n\nStatelessWidget (z ang. widget bezstanowy) to prosty element wizualny nie posiadający z definicji stanu oraz nie potrafiący sam się przerysować, gdy użytkownik wykona odpowiednią akcję. Przykładami są wbudowane we Fluttera Text, RaisedButton, czy Container. Przyjmują one parametry podczas tworzenia, ale nie zmieniają swojego wyglądu same z siebie podczas działania aplikacji.\n\nOd designu do kodu. Nie potrafimy jeszcze wykorzystać możliwości stanu, ale nic nie stoi na przeszkodzie, aby skupić się wpierw na części wizualnej. Tajemnicą poliszynela jest fakt, że tak przygotowany layout przekłada się 1:1 na wersję stanową, więc nie tracimy nawet minuty na bezsensowną implementację.\n\n\n  StatelessWidget - używaj go zawsze, gdy nie potrzebujesz przechowywać wewnętrznego stanu, który doprowadziłby do przerysowania komponentu.\n\n\nimport &#39;package:flutter/material.dart&#39;;\n\nvoid main() =&amp;gt; runApp(App());\n\nclass App extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        backgroundColor: Colors.amber,\n        body: HomeScreen(),\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      mainAxisAlignment: MainAxisAlignment.spaceAround,\n      children: [\n        Text(\n          &quot;60 sekund&quot;,\n          style: TextStyle(\n            color: Colors.black,\n            fontSize: 32,\n          ),\n        ),\n        Image.network(\n          &quot;http://pluspng.com/img-png/pikachu-face-png-png-svg-512.png&quot;,\n          width: 160,\n          height: 160,\n        ),\n        RaisedButton(\n          onPressed: () {},\n          color: Colors.black,\n          child: Padding(\n            padding: const EdgeInsets.all(16),\n            child: Text(&quot;Trenuj&quot;, style: TextStyle(color: Colors.white)),\n          ),\n        ),\n        Container(\n          padding: EdgeInsets.all(16),\n          color: Colors.black,\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n            children: [\n              StatsBox(label: &quot;Poziom&quot;, value: 1),\n              StatsBox(label: &quot;Atak&quot;, value: 0),\n              StatsBox(label: &quot;Obrona&quot;, value: 0),\n            ],\n          ),\n        ),\n      ],\n    );\n  }\n}\n\nclass StatsBox extends StatelessWidget {\n  StatsBox({\n    Key key,\n    this.label,\n    this.value,\n  }) : super(key: key);\n\n  final String label;\n  final int value;\n\n  Widget build(BuildContext context) {\n    return Column(\n      children: [\n        Text(\n          label,\n          style: TextStyle(\n            color: Colors.amber,\n            fontSize: 13,\n          ),\n        ),\n        Padding(\n          padding: const EdgeInsets.only(top: 8.0),\n          child: Text(\n            value.toString(),\n            style: TextStyle(\n              color: Colors.white,\n              fontSize: 24,\n              fontWeight: FontWeight.bold,\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}\n\n\nRozbiliśmy nasz layout na 3 widgety:\n\n\n  App - komponent startowy, okala resztę aplikacji pod kątem wykorzystania Material UI\n  HomeScreen - główny ekran rysujący naszą aplikację\n  StatsBox - pojedynczy rekord, który wyświetla jedną z dostępnych statystyk: poziom, atak, obrona.\n\n\nKod wygląda sensownie, więc budujemy naszą aplikację na emulatorze, lub urządzeniu. Po chwili mamy zbudowanego i działającego PokeTapa! Kliknięcie w przycisk Trenuj nie aktualizuje oczywiście naszych statystyk, a czasomierz na górze nie odlicza nieuniknionego. Zdawaliśmy sobie z tego sprawę (mam nadzieję) i wiemy co stanowi problem - brakuje nam stanu aplikacji.\n\nPraktyczny stan (StatefulWidget)\n\nStatefulWidget (z ang. widget stanowy) to element posiadający własny stan, którego zmiana wywołuje przerysowanie elementu wizualnego na ekranie. Dobrymi przykładami są widgety używane w formularzach takie jak TextField, czy Checkbox, które “pamiętają” wprowadzone do siebie dane i każda taka zmiana (np. wpisanie litery w polu tekstowym) prowadzi do automatycznej aktualizacji kontrolki na ekranie.\n\nW przeciwieństwie do widgetu bezstanowego, który swoje działanie opiera na pojedynczej klasie dziedziczącej po StatelessWidget, tutaj musimy się napracować ciut mocniej. Potrzebujemy dwóch części - stałej (publicznej) i zmiennej (prywatnej).\n\nDefinicja publiczna (stała)\n\nclass MyWidget extends StatefulWidget {\n    MyWidget({\n      Key key,\n      this.name,\n    }): super(key: key);\n    \n    final string name;\n    \n\t@override\n\t_MyWidgetState createState() =&amp;gt; new _MyWidgetState();\n}\n\n\nPubliczna część komponentu, której używasz w kodzie wyżej zupełnie jak dowolny StatelessWidget. W momencie gdy chcesz dodać element stanowy do drzewa - tworzysz instancję klasy poprzez new MyWidget() i gotowe.\n\nZ racji tego, że StatefulWidget rozszerza klasę Widget - wymusza to na niej bycie niezmienną (immutable) - jest to główny powód, dla którego wymagana jest dodatkowa część (z reguły prywatna). Więcej na ten temat znajdziesz na Stack Overflow.\n\nDefinicja prywatna (zmienna)\n\nclass _MyWidgetState extends State&amp;lt;MyWidget&amp;gt; {\n\t@override\n\tWidget build(BuildContext context) {\n\t    return Text(widget.name);\n\t}\n}\n\n\nDruga wymagana składowa do utworzenia widgetu stanowego. Jest to część zmienna (mutable), która może zmieniać swoje dane w trakcie życia - co spowoduje automatyczne przebudowanie elementu wizualnego. Zwróć uwagę na znak _ przed nazwą klasy - oznacza on, że klasa jest prywatna i nie można jej przykładowo zaimportować z innego pliku. Jeśli potrzebujesz do niej dostępu z zewnątrz - nie używaj prefixu _, nie jest on wymagany, lecz zalecany.\n\nDostęp do parametrów MyWidget z klasy _MyWidgetState odbywa się poprzez obiekt widget. W zademonstrowanym przykładie metoda build rysuje wartość z pola widget.name (name zadeklarowane jest w MyWidget).\n\nObiekt stanu przechowuje wszelkie dane, które mogą zmieniać się w trakcie działania (np. poziom naszego stworka), a także metodę build, która jest uruchamiana przy każdorazowej zmianie stanu przez wywołanie funkcji setState(() {}).\n\nZmiana stanu (setState)\n\nW celu zmiany aktualnego stanu obiektu posługujemy się funkcją setState, która dostępna jest na StatefulWidget. Powiadomi ona framework o tym, że stan został zmieniony, co spowoduje automatyczne przerysowanie. Mamy dwie możliwości na jego używanie - brzydką, lub oficjalną.\n\nBrzydka:\nvoid fn() {\n  clickCount++;\n  setState(() {});\n}\n\n\nOficjalna:\nvoid fn() {\n  setState(() {\n    clickCount++;\n  });\n}\n\n\nObie zadziałają identycznie, jednak ze względu na czytelność kodu mocno zalecam wariant oficjalny, bo:\n\n\n  Oficjalny jest zalecany przez framework\n  Przy code review od razu widać co się dzieje i mamy zgrupowane miejsce w którym dokonujemy zmiany stanu.\n\n\nKorzystając z podejścia oficjalnego pamiętaj o jeszcze jednej rzeczy - wewnątrz funkcji dostarczanej do setState nie wykonuj ciężkich obliczeń, ani innych operacji - dokonaj w niej jedynie przypisania wartości do stanu.\n\nŹle:\nvoid fn() {\n  setState(() {\n    doSomeHeavyCalc();\n    clickCount++;\n    someMoreExtraWork();\n  });\n}\n\n\nDobrze:\nvoid fn() {\n  setState(() {\n    clickCount++;\n  });\n  \n  doSomeHeavyCalc();\n  someMoreExtraWork();\n}\n\n\n\n  Używaj widgetu stanowego, gdy potrzebujesz wewnętrznego stanu, który będzie automatycznie aktualizował wizualną część kontrolki.\n\n\nZebranie myśli\n\nWiemy już co należy zrobić - musimy zamienić StatelessWidget na StatefulWidget i stworzyć dodatkową klasę na wymagany stan. Tylko który widget ma być stanowy? Wszystkie, czy wystarczy jeden? Żadna interakcja nie zachodzi zarówno w App jak i w StatsBox, możemy je więc zostawić w spokoju. HomeScreen jednak definitywnie potrzebuje pomocy - ma przycisk, który zmienia stan, a dodatkowo powinien się umieć przerysować w odpowiednim momencie. Mamy kandydata do przerobienia, sukces!\n\nDziałający prototyp (StatefulWidget)\n\nWprowadzanie niezbędnych zmian zaczniemy od przemiany HomeScreen na wersję stanową. Będziemy potrzebować dwóch klas, pamiętasz?\n\nPrzed:\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n\n\nPo:\nclass HomeScreen extends StatefulWidget {\n  @override\n  _HomeScreenState createState() =&amp;gt; _HomeScreenState();\n}\n\nclass _HomeScreenState extends State&amp;lt;HomeScreen&amp;gt; {\n  int secondsLeft = 60;\n  int level = 1;\n  int attack = 0;\n  int defense = 0;\n  \n  @override\n  Widget build(BuildContext context) {\n    // ...\n  }\n}\n\n\nWidget nabiera kształtu/rzeźby/masy. Sprawiliśmy, że potrafi się automatycznie przebudować poprzez posiadany stan, a dodatkowo zadeklarowaliśmy atrybuty, które przydadzą nam się już za moment do nadania trochę życia tej smutnej grze.\n\nMam nadzieję, że zadajesz sobie teraz pytanie “Co dalej?”, a nie “Dlaczego to jeszcze nie działa?”. Kolejną rzeczą której potrzebujemy jest wykorzystanie zadeklarowanych atrybutów w metodzie build, zamiast zahardkodowanych wartości. Mamy takie miejsca dwa - licznik na górze ekranu i statystyki na dole. Do pracy!\n\nPrzed:\nText(\n  &quot;60 sekund&quot;,\n  // ...\n)\n// ...\nchildren: [\n  StatsBox(label: &quot;Poziom&quot;, value: 1),\n  StatsBox(label: &quot;Atak&quot;, value: 0),\n  StatsBox(label: &quot;Obrona&quot;, value: 0),\n]\n\n\nPo:\nText(\n  &quot;$secondsLeft sekund&quot;,\n  // ...\n),\n// ...\nchildren: [\n  StatsBox(label: &quot;Poziom&quot;, value: level),\n  StatsBox(label: &quot;Atak&quot;, value: attack),\n  StatsBox(label: &quot;Obrona&quot;, value: defense),\n]\n\n\n\n  Jeśli nie spotkałeś się wcześniej z zapisem w formacie “$secondsLeft sekund” to jest to tzw. string interpolation. Służy on do wyświetlania ciągu znaków z dynamicznymi wartościami w środku.\n\n\nJesteśmy prawie u celu ukończenia naszej gry. Działa co prawda zupełnie jak wersja bezstanowa (wydmuszka), ale stan jest i czeka tylko aż go uaktywnimy. A kiedy chcemy to zrobić? Co w naszej aplikacji wymusza odświeżenie ekranu jak nie kliknięcie przycisku Trenuj! Eureka - brakuje obsługi kliknięcia w przycisk!\n\nPrzed:\nRaisedButton(\n  onPressed: () {},\n  // ...\n)\n\n\nPo:\nRaisedButton(\n  onPressed: train,\n  // ...\n)\n\n\nDodatkowo w obrębie klasy trzymającej stan zaimplementuj metodę train, która przeprowadzi jednorazowy trening stworka. Co powinna zrobić? Przede wszystkim zwiększyć poziom o jedno oczko (szybki grind) i podbić statystyki zgodnie ze wzorem podbijania statystyk:\n\nvoid train() {\n  setState(() {\n    var random = Random();\n\n    level += 1;\n    attack += random.nextInt(4) + 1;\n    defense += random.nextInt(3) + 1;\n  });\n}\n\n\nMój wzór opiera się na wartościach losowych, gdzie atak zwiększam między 1-4, a obronę o 1-3 punkty. Jeśli podoba Ci się koncept losowości (każda rozgrywka będzie inna!) to pamiętaj o zaimportowaniu na górze pliku modułu obsługującego liczby pseudolosowe.\n\nimport &#39;dart:math&#39;;\n\n\nJeśli masz inny pomysł, np. zależny od tego jaki poziom już posiadamy, lub ile czasu pozostało w grze to śmiało zrób to po swojemu - jesteś od teraz Indie Game Developerem.\n\nGra gotowa - można się zagrywać godzinami sekundami. A jeśli już przy sekundach jesteśmy to co z licznikiem czasu? Dlaczego nie odlicza nieuniknionego i pozwala expić w nieskończoność? Cóż - secondsLeft otrzymuje na starcie wartość 60 i nigdy jej nie zmienia, bo i kiedy? Jaką akcję ma wykonać użytkownik, żebyśmy zareagowali odjęciem sekundy z zegarka?\n\n\n  …\n\n\nTo było ciut podchwytliwe, bo przecież użytkownik nie musi podejmować żadnej akcji żeby czas upływał (zupełnie jak w realnym życiu). Ot - czas płynie nieubłaganie nawet jeśli nasz gracz patrzy tylko w ekran, nie dotykając i nie stukając w żadne miejsce na ekranie. Czy to oznacza, że stan można zaktualizować bez zewnętrznej ingerencji? Nie inaczej. To, że w większości przypadków aktualizujemy go po stosownej akcji, nie oznacza że nie możemy robić tego w dowolnym momencie. No to wio!\n\nOszlifowany diament (lifecycle events)\n\nNa zakończenie potrzebujemy aktualizować zmienną secondsLeft, co sekundę odejmując 1 od jej aktualnej wartości, aż do momentu gdy osiągniemy zero. Zero arbitralnie - po prostu nie chciałbym pokazywać użytkownikowi ujemnego czasu. Na nasze szczęście Dart dostarcza nam gotowe rozwiązanie w postaci Timer.periodic, którego zadanie polega na ciągłym odliczaniu określonego czasu (np. 1 sekundy) i uruchamianiu określonego kodu (np. setState). Brzmi legitnie. Zdefiniujmy funkcję aktualizującą stan zegara (na tym samym poziomie co funkcja train):\n\nvoid updateClock(Timer timer) {\n  if (secondsLeft == 0) {\n    // Do nothing\n    return;\n  }\n    \n  setState(() {    \n    secondsLeft -= 1;\n  });\n}\n\n\nFunkcja updateClock przyjmuje obiekt typu Timer - jest to wymaganie pochodzące z faktu, iż Timer.periodic jako parametru wymaga właśnie funkcji o takiej sygnaturze. Dodajmy brakujący import na górze pliku:\n\nimport &#39;dart:async&#39;;\n\n\nOstatni krok stanowi uruchamianie funkcji updateClock co sekundę, do czego przyda nam się poniższa wstawka:\n\nTimer.periodic(Duration(seconds: 1), updateClock);\n\n\nUmieść ją na samym początku metody build - chcemy aby licznik zaczął się odświeżać niezwłocznie przed pierwszym narysowaniem. Uruchamiamy aplikację i voila - dostępny czas ucieka jak przez palce. Zaraz, zaraz. Chyba jednak trochę za szybko!\n\n\n\nUruchamiamy nowy timer za każdym przebudowaniem widgetu, które następuje po każdorazowej aktualizacji stanu, które z kolei … dzieje się raz na sekundę za sprawą licznika. Zobrazujmy sobie początek tego szaleństwa:\n\n\n  Pierwsze narysowanie widgetu tworzy timer, który co sekundę zmienia pozostały czas (stan)\n  Po sekundzie timer zmienia secondsLeft z 60 na 59 poprzez wywołanie setState\n  Następuje przerysowanie komponentu (uruchamiana jest metoda build) i wystartowanie dodatkowego timera (taki sam jak w punkcie 1)\n  Po kolejnej sekundzie timer1 aktualizuje stan z 59 na 58\n  Mikrosekundę po nim timer2 aktualizuje stan z 58 na 57\n  Każda aktualizacja stanu rozpędza zegar coraz mocniej\n  No profit\n\n\nIdealnym rozwiązaniem problemu wydaje się uruchomienie tylko jednego timera i to w momencie pierwszego rysowania. Można by dodać flagę typu isFirstDraw, ale z pomocą przychodzą nam specjalne metody wbudowane, które automatycznie wołane są przez Fluttera w odpowiednim czasie życia widgetu tzw. lifecycle.\n\nDodanie do drzewa (initState)\n\nFunkcja initState uruchamiana jest jednorazowo na czas życia widgetu. Nazwa sugeruje, że możemy tutaj zainicjalizować wstępny stan, ale możemy również bez obaw wystartować nasz unikalny timer i mieć pewność, że initState nie zostanie zawołany więcej niż raz. Wyrzuć timer z builda i dodaj następującą funkcję:\n\nTimer timer;\n\n@override\ninitState() {\n  super.initState();\n  timer = Timer.periodic(Duration(seconds: 1), updateClock);\n}\n\n\nOd razu lepiej - licznik nie gna na złamanie karku i odlicza sekunda-po-sekundzie. Właśnie tego oczekiwaliśmy po naszej spokojnej grze.\n\n\n\nZdjęcie z drzewa (dispose)\n\nPokeTap jest grą bardzo prostą, która posiada wyłącznie jeden ekran. Wyobraź sobie jednak sytuację w której się rozrasta i możliwa jest nawigacja między różnymi ekranami (np. listing stworków). W takim przypadku warto rozważyć czy kod, który uruchamiamy w initState wymaga “posprzątania” przed opuszczeniem ekranu.\n\ninitState startuje nowy timer, który co sekundę wywoła funkcję uploadClock. Jeśli wyjdziemy z tego ekranu (w przyszłości, gdy będzie to możliwe) to timer dalej będzie robił swoje. Flutter nie posprząta za nas wszystkiego - wyczyści widget oraz jego stan, ale nie zdaje sobie sprawy z naszych programistycznych poczynań. Musimy znaleźć więc sposób aby wykonać dodatkowy kod, który zatrzyma timer w momencie usuwania widgetu z ekranu. Dispose to the rescue!\n\n@override\nvoid dispose() {\n  timer.cancel();\n  super.dispose();\n}\n\n\nPamiętaj - kod nie ma żadnego praktycznego zastosowania w aktualnej wersji aplikacji, nie musisz go więc nanosić na swój projekt. Wspominam o metodzie dispose wyłącznie dla dopełnienia przeciwieństwa initState. Sam temat metod lifecycle jest na tyle ważny i warty poznania, że na pewno pojawi się krótki wpis na blogu dedykowany właśnie nim.\n\nDalsze plany\n\nMamy to - w pełni działająca gra typu clicker, bez żadnych udziwnień. Możesz je rzecz jasna dodać i rozszerzyć koncept, a ostatecznie nawet wydać na Android i iOSa. Wierzę, że wszystko okazało się jasne i potrafisz zarządzać stanem swojej Flutterowej aplikacji. Skomentuj wpis jeśli chciałbyś się czymś podzielić, lub masz dowolne pytanie. Wyszeruj dalej, aby więcej Flutter devów dowiedziało się co i jak. Do następnego wpisu!\n\nPełny kod aplikacji PokeTap znajdziesz na GitHubie.\n"
} ,
  
  {
    "title"    : "Pozycjonowanie elementów w gridzie - Row i Column",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-layout-grid/",
    "date"     : "June 23, 2019",
    "excerpt"  : "Ogromną rolę przy tworzeniu aplikacji mobilnych odgrywa część wizualna, czyli User Interface (UI). Możemy tutaj wyodrębnić kilka składowych elementów, które w połączeniu wygenerują nam to co użytkownik zobaczy na ekranie po odpaleniu naszej apki:\n...",
  "content"  : "Ogromną rolę przy tworzeniu aplikacji mobilnych odgrywa część wizualna, czyli User Interface (UI). Możemy tutaj wyodrębnić kilka składowych elementów, które w połączeniu wygenerują nam to co użytkownik zobaczy na ekranie po odpaleniu naszej apki:\n\n\n  wygląd komponentów (design)\n  animacje\n  rozmieszczenie komponentów (layout)\n\n\nWszystkie z nich są ważne i trudno sobie wyobrazić profesjonalny produkt bez chociażby jednej z nich. Dzisiaj skupię się na ostatniej, czyli w jaki sposób rozmieszczać komponenty na ekranie, aby spełniały nasze oczekiwania (lub oczekiwania Design Team-u). Jest to rzecz, która potrafi być frustrująca - zwłaszcza na początku przygody z technologią. O ile łatwo wyszukać w dokumentacji elementy wizualne, które umiemy sobie wyobrazić - przycisk, listę, czy belkę nawigacji - to znalezienie odpowiedzi na pytanie jak sprawić, żeby rzecz X była obok rzeczy Y, która jest nad rzeczą Z bywa zdecydowanie trudniejsze.\n\nLayout == widget\n\nTak jak człowiek w większości składa się z wody, tak Flutter opiera się w znacznej części na widgetach. Są nimi zarówno przyciski, przełączniki, ikony, a nawet wyświetlany na ekranie tekst, jak również obiekty których nie widzi nasz użytkownik, a mimo to znajdują się na ekranie i pełnią krytyczną rolę. Mowa tutaj o wierszach (Row) i kolumnach (Column), które w elegancki sposób organizują kolejność wyświetlania widgetów wizualnych.\n\nW dostępnej skrzynce narzędziowej mamy rzecz jasna do dyspozycji więcej narzędzi niż tylko wiersz/kolumna - o tym przeczytasz w kolejnym wpisie. Nie przedłużając wstępu - przejdźmy do praktyki i realnych zastosowań gridu!\n\nCentralna rozgrzewka\n\nPamiętasz jak zaczyna się każdy kurs dowolnego języka programowania? Oczywiście że tak, trudno zapomnieć te dwa magiczne słowa: Hello world. Tak samo zaczniemy i my - wyświetlimy ten napis na samym środku ekranu. Jedyna różnica będzie polegała na tym, że posłużymy się polską wersją językową tego zwrotu.\n\nimport &#39;package:flutter/material.dart&#39;;\n\nvoid main() =&amp;gt; runApp(App());\n\nclass App extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        backgroundColor: Colors.black,\n        body: Center(\n          child: Text(\n            &quot;Witaj świecie&quot;,\n            style: TextStyle(\n              fontSize: 32,\n              color: Colors.white,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\nNa urządzeniu zobaczysz czarne tło na całej powierzchni, a na środku ekranu napis “Witaj świecie” - tak jak na załączonym poniżej zrzucie. Nie jest to co prawda przykład zbyt złożony, ale od czegoś trzeba zacząć - teraz będzie tylko trudniej lepiej.\n\n\n\nCzy taki layout ma realne zastosowanie w produkcyjnej aplikacji? Oczywiście! W jednej ze swoich gier wyświetlam ekran informujący gracza o poprawnej odpowiedzi. Jest to prosty ekran z tłem i zadowoloną buźką w środku. Rozwiązanie proste i dające efekt który chciałem osiągnąć:\n\n\n\nGrid\n\nPierwsze rozmieszczenie za nami, jednak trudno zbudować aplikację której layout będzie opierał się wyłącznie na pojedynczym elemencie wyświetlanym na środku ekranu. W przykładzie powyżej możesz zaobserwować, że zarówno Container jak i Center przyjmują parametr child (z angielskiego dziecko - liczba pojedyncza), któremu można przekazać tylko jeden widget. Nie mamy możliwości przekazania listy elementów które chcemy narysować. Żegnaj przygodo.\n\nJeśli posiadasz doświadczenie jako Web Developer i pracowałeś chociaż przez krótką chwilę z HTML to coś Ci tu nie pasuje. Przecież do &amp;lt;div&amp;gt;, czy dowolnego innego znacznika można przekazać tyle elementów ile sobie zażyczę! Co to za herezja, aby blokować taką możliwość? Odpowiedź jest następująca: Flutter musi wiedzieć jak poukładać listę komponentów - pionowo? poziomo? - i dlatego dostarcza nam dedykowane widgety, które wiedzą co i jak.\n\nRow\n\nDo umieszczania elementów w poziomie (jeden obok drugiego) posługujemy się widgetem Row. W odróżnieniu od wielu innych wbudowanych komponentów nie przyjmuje on parametru child, lecz children (z angielskiego dzieci - liczba mnoga) do którego jesteśmy w stanie przekazać listę obiektów do narysowania.\n\nNapiszmy prostą aplikację, której zadaniem będzie wyświetlanie pojedynczych liter ze słowa Witaj w kolorowych bloczkach, które narysujemy jeden obok drugiego (od lewej do prawej).\n\nclass App extends StatelessWidget {\n  Widget buildItem(String letter, Color color) {\n    return Container(\n        padding: EdgeInsets.all(16),\n        decoration: BoxDecoration(color: Colors.blue),\n        child: Text(\n          letter,\n          style: TextStyle(\n            fontSize: 32,\n            color: color,\n          ),\n        )\n    );\n  }\n  \n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        backgroundColor: Colors.black,\n        body: Container(\n          height: 300,\n          decoration: BoxDecoration(color: Colors.green),\n          child: Row(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              buildItem(&quot;W&quot;, Colors.black),\n              buildItem(&quot;I&quot;, Colors.white),\n              buildItem(&quot;T&quot;, Colors.black),\n              buildItem(&quot;A&quot;, Colors.white),\n              buildItem(&quot;J&quot;, Colors.black),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\nPo uruchomieniu aplikacji powinieneś zobaczyć następujący zrzut:\n\n\n\nO to dokładnie nam chodziło! Czarne tło pochodzi z Scaffold, który zawsze okupuje pełny rozmiar ekranu. Na górze widzimy zieloną część o wysokości 300 jednostek z kontenera Container. Dlaczego ustawiliśmy sztywną wysokość? Widget ten domyślnie zajmie tyle miejsca na ekranie, ile miejsca potrzebuje jego dziecko - w tym wypadku Row. W celu demonstracyjnym konfiguracji tego ostatniego - narzuciliśmy mu wymiar umożliwiający swobodną zmianę dostępnych parametrów pozycjonowania.\n\nmainAxisAlignment\n\n\n\nGłówna oś na której rozmieszczone są elementy. Jeśli pamiętasz ze szkoły oś współrzędnych X Y to mamy tutaj naszego X. W przykładzie wykorzystaliśmy wartość spaceAround, jednak dostępne są również inne  warianty konfiguracyjne.\n\n\n  spaceAround - układa elementy na całej dostępnej szerokości i z każdej ze stron dodaje tzw. światło, czyli pustą przestrzeń. Wolna przestrzeń między dziećmi jest 2x większa, niż ta oddzielająca dziecko od rodzica\n  spaceEvenly - identyczne zachowanie jak spaceAround, z tą różnicą, że przestrzeń między elementami i rodzicem jest jednakowej wielkości.\n  spaceBetween - podobnie jak spaceAround elementy rozłożone są na całej szerokości, jednak bez pustej przestrzeni z przodu i na końcu (przyleganie do krawędzi rodzica).\n  start - elementy przylegają do siebie i ustawiane są na początku osi (lewa strona).\n  center - elementy przylegają do siebie i ustawiane są na środku osi.\n  end - analogicznie jak start z tym, że elementy stłoczone są na końcu osi (prawa strona).\n\n\n\n\ncrossAxisAlignment\n\n\n\nDodatkowa oś, która odpowiada za pionowe rozmieszczenie elementów (Y). Nasz przykład używa wartości center, jednak dostępnych wariantów jest więcej i wszystko zależy od tego jaki efekt chcesz uzyskać.\n\n\n  center - wymusza rozkład w centralnej części wiersza. Elementy znajdują się na środku ekranu, tak jak po użyciu widgetu Center.\n  start - elementy umieszczone są na samej górze kontenera.\n  end - przeciwieństwo start, elementy widoczne są na dole.\n  stretch - służy do rozciągnięcia elementów w taki sposób, aby zapełniły całą dostępną wysokość.\n  baseline - opcja przydatna jedynie gdy elementami składowymi wiersza jest bezpośrednio tekst, który chcemy wyrównać względem siebie. Parametr do poprawnego działania wymaga ustawienia dodatkowego parametru textBaseline na rodzicu Row.\n\n\n\n\nColumn\n\nWiemy już jak rozmieszczać elementy w poziomie, czas przyjrzeć się jak zrobić to samo dla pionu (jeden pod drugim). Zadanie to powierzamy widgetowi Column, który działa w sposób analogiczny jak Row. Najważniejsze różnice to:\n\n\n  Elementy rozmieszczone są pionowo, nie poziomo.\n  Column okupuje maksymalną dostępną wysokość rodzica, a szerokość tylko taką jakiej potrzebuje do narysowania najszerszego ze swoich dzieci (Row zajmuje maksymalną szerokość, a wysokość najwyższego z dzieci).\n\n\nNanieśmy odpowiednie modyfikacje do poprzedniego kodu. Jedynymi zmianami, które wprowadzimy jest ustalanie szerokości zamiast wysokości (height na width) i podmiana widgetu Row na Column. Cała reszta pozostaje bez zmian.\n\nclass App extends StatelessWidget {\n  Widget buildItem(String letter, Color color) {\n    return Container(\n        padding: EdgeInsets.all(16),\n        decoration: BoxDecoration(color: Colors.blue),\n        child: Text(\n          letter,\n          style: TextStyle(\n            fontSize: 32,\n            color: color,\n          ),\n        )\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        backgroundColor: Colors.black,\n        body: Container(\n          // height replaced with width\n          width: 300,\n          decoration: BoxDecoration(color: Colors.green),\n          // Row changed to Column\n          child: Column(\n            mainAxisAlignment: MainAxisAlignment.spaceAround,\n            crossAxisAlignment: CrossAxisAlignment.center,\n            children: [\n              buildItem(&quot;W&quot;, Colors.black),\n              buildItem(&quot;I&quot;, Colors.white),\n              buildItem(&quot;T&quot;, Colors.black),\n              buildItem(&quot;A&quot;, Colors.white),\n              buildItem(&quot;J&quot;, Colors.black),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\nUruchomienie aplikacji spowoduje wyświetlenie poniższego ekranu:\n\n\n\nPonownie uzyskujemy spodziewany wynik! Elementy narysowane są jeden pod drugim, a czarny pas po prawej stronie to nic innego jak Scaffold umieszczony pod spodem naszego layoutu. Na koniec przyjrzyjmy się opcjom konfiguracyjnym - jest to czysta formalność, gdyż ustawienia przekładają się 1:1 z tym co widzieliśmy w Row.\n\nmainAxisAlignment\n\n\n\nJako, że widget służy do układania komponentów w pionie to jego główną osią nie jest X, lecz Y. Trzeba o tym pamiętać - mi do tej pory zdarza się sporadycznie ustawić parametry nie tak jak powinienem. Konfiguracja jest identyczna jak w Row, pozwól, więc że nie będę jej tutaj ponownie wklejał.\n\n\n\ncrossAxisAlignment\n\n\n\nDruga z osi, która rozmieszcza elementy w poziomie X. Ponownie opcje konfiguracyjne możesz podejrzeć w sekcji w której omawialiśmy widget Row.\n\n\n\nSynteza\n\nPrzeszliśmy przez pozycjonowanie poziome i pionowe - jest to mocny fundament przy projektowaniu layoutu naszej aplikacji. Możesz (a nawet powinieneś) osadzać kolumny w wierszach, a wiersze w kolumnach. W końcu Column i Row to widgety, nic więc nie stoi na przeszkodzie aby w drzewie komponentów zawierały się wzajemnie.\n\nNa zakończenie spójrz jeszcze na bardziej złożony (ale nieskomplikowany!) ekran, który posiada wiele różnych elementów i demonstruje w jaki sposób uzyskać pożądany efekt:\n\n\n\nimport &#39;package:flutter/material.dart&#39;;\n\nvoid main() =&amp;gt; runApp(App());\n\nclass App extends StatelessWidget {\n  Widget buildInfo(Icon icon, String text) {\n    return Column(\n      children: [\n        icon,\n        Padding(\n          padding: const EdgeInsets.only(top: 8.0),\n          child: Text(text, style: TextStyle(color: Colors.white)),\n        ),\n      ],\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        backgroundColor: Colors.amber,\n        body: Column(\n          mainAxisAlignment: MainAxisAlignment.spaceAround,\n          children: [\n            Column(\n              children: &amp;lt;Widget&amp;gt;[\n                Text(\n                  &quot;Pikachu&quot;,\n                  style: TextStyle(\n                    color: Colors.black,\n                    fontSize: 48,\n                    fontWeight: FontWeight.bold,\n                  ),\n                ),\n                Image.network(\n                  &quot;http://pluspng.com/img-png/pikachu-face-png-png-svg-512.png&quot;,\n                  width: 160,\n                  height: 160,\n                ),\n              ],\n            ),\n            Text(\n              &quot;Pikachu jest jednym z najbardziej rozpoznawalnych Pokémonów, &quot;\n              &quot;głównie ze względu na fakt, że jest on centralną postacią w serii anime. &quot;\n              &quot;Pikachu jest powszechnie uważany za najbardziej popularnego Pokémona.&quot;,\n              textAlign: TextAlign.center,\n              style: TextStyle(height: 1.4, fontSize: 16),\n            ),\n            Container(\n              padding: EdgeInsets.all(16),\n              color: Colors.black,\n              child: Row(\n                mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n                children: [\n                  buildInfo(\n                    Icon(Icons.flash_on, color: Colors.yellowAccent),\n                    &quot;Type&quot;,\n                  ),\n                  buildInfo(\n                    Icon(Icons.insert_emoticon, color: Colors.greenAccent),\n                    &quot;Mood&quot;,\n                  ),\n                  buildInfo(\n                    Icon(Icons.do_not_disturb_alt, color: Colors.redAccent),\n                    &quot;Full HP&quot;,\n                  ),\n                ],\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n"
} ,
  
  {
    "title"    : "Flutter - konfiguracja i rozpoczęcie przygody",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-getting-started/",
    "date"     : "June 12, 2019",
    "excerpt"  : "Czym jest Flutter możesz dowiedzieć się z poprzedniego wpisu, pora na praktykę. Konfiguracja środowiska,\ninstalacja niezbędnych zależności, podrasowanie edytora i ostatecznie zbudowanie pierwszej apki pod Androida lub iOSa (exclusive dla posiadacz...",
  "content"  : "Czym jest Flutter możesz dowiedzieć się z poprzedniego wpisu, pora na praktykę. Konfiguracja środowiska,\ninstalacja niezbędnych zależności, podrasowanie edytora i ostatecznie zbudowanie pierwszej apki pod Androida lub iOSa (exclusive dla posiadaczy macOS). Zacznijmy kodzić!\n\n\n\nFlutter SDK\n\nDo rozpoczęcia naszej przygody z Flutterem potrzebujemy … Fluttera. Da się zrobić! SDK dostępne jest do pobrania bezpośrednio z serwerów Google:\n\n\n  Wersja Linux\n  Wersja macOS\n\n\nPo ściągnięciu paczki należy ją rozpakować, a następnie przenieść katalog w sensowne miejsce. Jak odróżnić sensowne, od bezsensownego? Nie wiem, ale rzeczy tego typu osobiście trzymam w /usr/local/opt/ dlatego Tobie też to polecam (chyba, że masz wyrobione własne preferencje, wtedy śmiało zrób tak, abyś czuł że masz nad tym kontrolę). Otwórz konsolę i przenieś świeżo rozpakowane archiwum do miejsca docelowego:\n\ncd &amp;lt;KATALOG_GDZIE_ROZPAKOWAŁEŚ_ARCHIWUM&amp;gt;\nmv flutter /usr/local/opt/\n\n\nGotowe. Pozostaje nam tylko powiadomić system, że w /usr/local/opt/flutter/bin/ znajdują się pliki wykonywalne, które będziemy uruchamiać z poziomu konsoli. Chcemy w terminalu wpisać flutter i zobaczyć inny output niż “Command not found”. Do osiągnięcia celu zaktualizujemy zmienną środowiskową $PATH:\n\necho export PATH=&#39;$PATH:/usr/local/opt/flutter/bin&#39; &amp;gt;&amp;gt; ~/.bash_profile\n\n\nZrestartuj konsolę i voilà - po wpisaniu flutter --version otrzymasz informację o aktualnie zainstalowanej wersji Fluttera. Yay!\n\nŚrodowisko Android\n\nBudowanie aplikacji na urządzenia z Androidem wymaga pobrania i zainstalowania Android Studio. Gdy zainstalujesz już program, uruchom go i przejdź przez sugerowany proces pobierający Android SDK wraz z platform-tools i build-tools (narzędzia wykorzystywane m.in. do budowania plików *.apk).\n\nJako że główne narzędzie masz już zainstalowane, pozostało przygotować urządzenie na którym będziesz testował aplikację. Generalnie opcje są dwie - telefon, albo emulator. Oba rozwiązania są dobre, jednak czasem konieczne jest przetestowanie na fizycznym urządzeniu - bo jak sprawdzisz, że emulator wibruje? Ograniczenia technologiczne :)\n\nKonfiguracja urządzenia\n\n\n  Weź telefon do ręki.\n  Przejdź do ustawień i aktywuj opcje programistyczne Ustawienia &amp;gt; Informacje o telefonie &amp;gt; Numer kompilacji/wersji.  Uderz kilkanaście razy w tą opcję póki nie dostaniesz informacji o tym, że zostałeś programistą. Jeśli monit o byciu programistą się nie pojawi - spróbuj uderzać palcem w inną opcję, lub sprawdź w internecie jak dokładnie wygląda to na Twoim urządzeniu.\n  W ustawieniach odblokowana została nowa sekcja Opcje programistyczne. Przejdź do niej i włącz opcję Debugowanie USB oraz Zezwalaj na instalację USB (nie we wszystkich telefonach jest dostępna).\n  Podłącz kablem telefon do komputera.\n  Na telefonie potwierdź, że ufasz komputerowi do którego się właśnie podłączyłeś (bo ufasz prawda?).\n\n\nKonfiguracja emulatora\n\n\n  Uruchom Android Studio i z menu wybierz Tools &amp;gt; AVD Manager.\n  Kliknij w przycisk na dole ekranu Create virtual device.\n  W Category zaznacz Phone, wybierz dowolne urządzenie i kliknij w Next.\n  Wybierz wersję Androida do zainstalowana na emulatorze (polecam jedną z nowszych). Jeśli nie ściągałeś jeszcze żadnej to przy obrazach dostępny jest przycisk Download, który pobierze potrzebne pliki.\n  Kliknij w Next, a następnie Finish.\n  Wróć do Tools &amp;gt; AVD Manager i kliknij w ikonę ▶️ przy nowo utworzonym emulatorze.\n\n\nZwieńczeniem procesu - bez znaczenia czy konfigurujesz urządzenie czy emulator - jest wpisanie z poziomu konsoli flutter devices i upewnienie się że zwrócona lista nie jest pusta. Powinieneś otrzymać wynik zbliżony do:\n\n$ flutter devices\n1 connected device:\n\nAndroid SDK built for x86 • emulator-5554 • android-x86 • Android 9 (API 28) (emulator)\n\n\nŚrodowisko iOS*\n\nWyłącznie dla posiadaczy macOS - nie jest możliwe budowanie aplikacji iOS na innym systemie operacyjnym niż ten od Apple.\n\nJeśli jesteś zainteresowany budowaniem aplikacji pod iOS, potrzebujesz narzędzia Xcode. Po poprawnej instalacji (może chwilę zająć) wykonaj dodatkowo poniższe polecenia:\n\nsudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\nsudo xcodebuild -license\n\n\nOdpowiadają one za konfigurację CLI oraz akceptację umowy licencyjnej (bez jej czytania, Wow!).\n\nKonfiguracja emulatora\n\n\n  Z konsoli wpisz open -a Simulator\n\n\nW przypadku gdy chcesz sprecyzować jakie urządzenie ma zostać uruchomione (np. wolisz iPhone SE niż iPhone X):\n\n\n  Uruchom Xcode.\n  Utwórz nowy projekt przez File &amp;gt; New &amp;gt; Project (⇧⌘N).\n  Jako szablonu użyj Single View App.\n  Patrz obrazek: \n\n\nUpewnij się, że opcja Debug &amp;gt; Slow animations jest wyłączona. Lubi czasem spłatać figla i się włączyć po cichu.\n\nPunkt kontrolny\n\nCzas się zatrzymać i zweryfikować, że wszystko zostało poprawnie zainstalowane i skonfigurowane. Flutter posiada do tego wbudowane polecenie, które upewni się że wszystko jest w jak najlepszym porządku.\n\n$ flutter doctor\n\nDoctor summary (to see all details, run flutter doctor -v):\n[✓] Flutter (Channel stable, v1.5.4-hotfix.2, on Mac OS X 10.14.5 18F132, locale pl-PL)\n[✓] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[✓] iOS toolchain - develop for iOS devices (Xcode 10.2.1)\n[✓] Android Studio (version 3.4)\n[✓] VS Code (version 1.35.0)\n[✓] Connected device (1 available)\n\n• No issues found!\n\n\nWypis zawiera informację o:\n\n  Flutter - w jakiej wersji zainstalowany jest sam framework\n  Android toolchain - narzędzia do budowania aplikacji pod Androida\n  iOS toolchain - narzędzia do budowania aplikacji pod iOSa (dostępne wyłącznie na macOS)\n  Android Studio - IDE do tworzenia aplikacji\n  VS Code - nie-IDE (edytor tekstu) do tworzenia aplikacji\n  Connected devices - suma podłączonych urządzeń+uruchomionych emulatorów\n\n\nNie przejmuj się jeśli przy części opcji masz krzyżyk (chyba, że przy wszystkich) - możesz przykładowo nie chcieć instalować VS Code, czy też na początku chcesz pisać aplikację wyłącznie pod Androida.\n\nUruchomienie aplikacji\n\nNajłatwiejszym sposobem na uruchomienie czystej aplikacji we Flutterze jest utworzenie nowego projektu i jego odpalenie.\n\n\n\nTakże to też zrobimy. Wsiadaj do konsoli i wpisuj razem ze mną:\n\nflutter create my_app\ncd my_app\nflutter run\n\n\nTwoim oczom powinna ukazać się następująca aplikacja startowa:\n\n\n\nJest to typowy counter w którym po kliknięciu przycisku, licznik się zwiększa i tak bez końca. Teraz masz już 100% pewność, że Flutter gra i buczy i pozostaje Ci jedynie pure development, czyli to czym chcesz się zająć na poważnie. Ze swojej strony polecam oficjalny tutorial na flutter.dev, który krok po kroku przedstawia najważniejsze składowe frameworka.\n\n\n"
} ,
  
  {
    "title"    : "Nowy gracz aplikacji mobilnych - Flutter",
    "category" : "",
    "tags"     : " ",
    "url"      : "/blog/flutter-intro/",
    "date"     : "June 9, 2019",
    "excerpt"  : "Flutter to nowa technologia od Google służąca do tworzenia aplikacji mobilnych. Nie ma tutaj jednak mowy o stricte natywnym podejściu (od tego jest Kotlin, czy Swift), lecz o cross-platformowym frameworku, w którym kod piszemy raz i robimy release...",
  "content"  : "Flutter to nowa technologia od Google służąca do tworzenia aplikacji mobilnych. Nie ma tutaj jednak mowy o stricte natywnym podejściu (od tego jest Kotlin, czy Swift), lecz o cross-platformowym frameworku, w którym kod piszemy raz i robimy release na oba systemy - Android oraz iOS. Brzmi świetnie, prawda? I tak jest w rzeczywistości. Nie utrzymujemy dwóch całkowicie niezależnych bytów natywnych, nie uczymy się dwóch odmiennych od siebie języków programowania, nie poznajemy tak dogłębnie dwóch różnych systemów, czy też środowisk. W naszej kwestii jako programisty pozostaje wytworzenie aplikacji mobilnej, a Flutter zajmie się tym, aby poprawnie działała na obu platformach.\n\n\n\nDeja-vu\n\nCzy Flutter to rewolucja na miarę naszych czasów? Całkowity zwrot świata mobilno-developerskiego w stronę aplikacji którą piszemy raz i uruchamiamy gdziekolwiek chcemy? Bez przesady - rozwiązania tego typu istnieją już od jakiegoś czasu, a mimo to development natywny ma się bardzo dobrze i nigdzie się nie wybiera. Fluttera należy traktować zdecydowanie bardziej jako ewolucję w sposobie w jakim piszemy aplikacje tego typu.\n\nNa rynku mamy co najmniej kilkanaście innych rozwiązań, które celują w ten sam problem - jak zarobić zbudować aplikację mobilną która pokryje oba systemy i się nie narobić. Każda technologia rozwiązuje problem na inny sposób, z lepszym bądź gorszym skutkiem, który ostatecznie definiuje jak bardzo przyjmie się na rynku i jak dużą świadomość wywrze na developerach. Oto lista narzędzi z którymi miałem przyjemność mniej-lub-bardziej pracować:\n\nIonic\n\nNajstarsze z wymienianych tutaj rozwiązań i w moim odczuciu najsłabsze. Pomimo tego że projekt jest aktywnie rozwijany i dostarcza naprawdę fajny ekosystem, to czasy swojej świetności ma już dawno za sobą. Aplikacje pisane są w JavaScript, HTML i CSS. Tak, jest to bardzo znajomy stack technologiczny dla web-developerów, ale nie bez powodu. Aplikacje napisane w Ionicu nie są kompilowane do niczego co choćby przypominałoby kod natywny. Sztuczka budowania polega na tym, że tworzymy naszą aplikację (zupełnie jak stronę internetową), a następnie jest ona pakowana w taki sposób, aby jej uruchomienie na fizycznym urządzeniu odpaliło w tle przeglądarkę, która obsłuży w trybie pełnoekranowym naszą aplikację. Rozwiązanie jest mało wydajne, zwłaszcza gdy operujemy na dużej ilości danych, lub gdy chcemy wprowadzić zaawansowane animacje do projektu. Nie jest jednak tak, że Ionic jest złą opcja gdy wybieramy główne narzędzia do stworzenia aplikacji mobilnej. W przypadku, gdy zależy nam na:\n\n\n  stworzeniu produktu który będzie działał z pudełka na Android, iOS oraz przeglądarce\n  szybkim prototypie aby zwalidować pomysł biznesowy\n  błyskawicznym wykorzystaniu znanych technologii (JS, HTML, CSS)\n\n\nWarto poważnie rozważyć tę technologię jako dobrego kandydata. Możemy szybko przygotować prototyp, który będzie dostępny dla użytkowników mobilnych (aplikacja pobierana ze sklepu), jak również przez przeglądarkę dla użytkowników desktopowych, czy tych którzy korzystają z innego systemu mobilnego (m.in. Windows Phone).\n\nXamarin\n\nPrawdziwka gratka dla programistów platformy .NET i języka C#, którzy chcą stworzyć aplikację mobilną. Właścicielem frameworka jest Microsoft, który w 2016 roku przejął startup i od tego momentu kieruje jego dalszym rozwojem. Jest to jedyna technologia z którą nie mam prawdziwego komercyjnego doświadczenia - jedynie projekty hobbystyczne - głównie za sprawą faktu, że nie pojawiła się między nami chemia (przez “nas” mam na myśli C# i mnie). Po prostu, tak bywa. Warto zaznaczyć, że w przeciwieństwie do Ionica mamy tutaj do czynienia z aplikacją, która kompiluje się do natywnego (w uproszczeniu) kodu. Daje nam to spory skok wydajnościowy, dzięki któremu użytkownicy aplikacji nie są w stanie stwierdzić na podstawie płynności działania, czy korzystają z aplikacją natywnej, czy też nie. A do tego przede wszystkim sprowadza się pisanie oprogramowania typu cross-platform.\n\nReact Native\n\nZ jednej strony mój ex-ulubieniec, z drugiej koszmarek który śni się po nocach. Głównym motorem napędowym jest jak w przypadku Ionica - JavaScript. Można ten język kochać, można nienawidzić, a można (to ja!) po prostu traktować go jako kolejne narzędzie wykorzystywane w pracy, które jak wszystko - ma swoje wady i zalety - wystarczy je poznać i zaakceptować. Nie chcę się jednak rozwodzić nad językiem, a nad frameworkiem. Jest to na dzień dzisiejszy czarny koń wyścigu zbrojeń cross-platformowego. Najpopularniejsze dłuto do rzeźbienia naszych cross-platformowych aplikacji. Posiada ogromny ekosystem (paczki które zrobią za nas 50% projektu) oraz community (stackoverflow, eventy, grupy dyskusyjne). Jeśli mowa o paczkach - te są naprawdę w dużej części dobre. Co to są dobre paczki? A no takie, które są dojrzałe, utrzymywane, aby działały na kolejnych wersjach Androida, czy iOSa, a także wystawiają bogaty interfejs do operowania. Prawdziwa machina open-source. Dodatkowo bardzo często klienci, którzy potrzebują aplikacji mobilnej chcą aby została napisana właśnie w React Native. Skąd klient stricte biznesowy wie o technologii? Dlaczego akurat ta, a nie inna? To proste - marketing, rozpoznawalność, dojrzałość na rynku sprawiły, że gdy myślisz o aplikacji mobilnej ze współdzielonym kodem to mózg automagicznie rysuje wizerunek React Native.\n\nCzy mamy więc rozwiązanie idealne? Oczywiście, że nie - nie ma rozwiązań idealnych, a każde kłuje na swój własny specyficzny sposób. Z projektów nad którymi pracowałem w tej technologii wyłania się zawsze podobny zestaw problemów:\n\n\n  trudność w aktualizacji w istniejącym projekcie - podbicie wersji React Native niemal zawsze prowadzi do traumy i rozwiązywania mistycznych błędów, które nie powinny mieć miejsca. W skrajnych przypadkach najlepszym wyjściem z sytuacji jest utworzenie czystego projektu z nową wersją React Native i przenoszenie tam naszego kodu projektowego - brzmi źle, ale skoro działa to warto się pochylić\n  niedeterministyczne działanie aplikacji - nie zliczę sytuacji w których aplikacja budowała się poprawnie w piątek, a w poniedziałek po południu coś było nie tak. A to przestał działać live reload, a to hot reload dostaje czkawki. Aplikacja przestała się budować, lub urządzenie nie widzi bundla developerskiego? Standard. W pewnym momencie po prostu się przyzwyczajasz i masz swój własny zestaw komend defibrylacyjnych, którymi się dzielisz z zespołem projektowym.\n  jakość zgłaszanych błędów - czerwony ekran który jako developerzy dostajemy co jakiś czas, gdy zepsujemy nasz kod. O ile doskonale rozumiem, że błędy się zdarzają i nikt nie pisze kodu w taki sposób, aby nie był mu potrzebny backspace, to komunikaty które dostajemy wołają o pomstę do debuggera. Tak jak w punkcie wyżej - po jakimś czasie mózg buduje mapę co znaczy dany komunikat i w jakich przypadkach się pojawia (jak choćby błędny import) i z automatu wiemy co nabroiliśmy\n\n\nSą również inne mniejsze, bądź większe problemy, jednak bardziej specyficzne dla konkretnego projektu. Mimo wad, szczerze uważam, że React Native jest technologią w którą warto inwestować swój czas - m.in. za sprawą mnogości ofert pracy, niższym progiem wejścia jeśli znasz już JavaScript, a także bogatego ekosystemu.\n\n\n\nInne\n\nTemat alternatywnych technologii nie jest wyczerpany. Istnieje wiele innych bibliotek, czy frameworków które rozwiązują podobny problem co Flutter, jednak jest to już “drobnica” dla zapaleńców, czy programistów hobbystycznych (bez obrazy). Jeżeli zależy Ci na technologii która będzie rozwijana i wspierana przez najbliższe lata - doświadczenie jasno mi podpowiada, że należy postawić na rozwiązanie za którym stoi dedykowany sztab techniczny dużej firmy (bo tylko taka może sobie na to pozwolić), a nie za frameworkiem krzakiem, który może się pochwalić jedynie ładnym landing-page, a możliwości i jakiekolwiek wsparcie kończy się tuż po zainstalowaniu paczki na naszym lokalnym środowisku. Stwierdzenie brutalne, lecz prawdziwe.\n\nFlutter\n\nSkoro wiemy już czym są aplikacje cross-platformowe i wiemy, że problem został już dawno rozwiązany - to co robi tu Flutter? Jakie karty wnosi do gry i do kogo dokładnie jest skierowany? Mamy już przecież młotek do szybkiego pisania wolnych aplikacji (Ionic), do pisania w ekosystemie typu enterprise (Xamarin), czy do tworzenia niemal natywnych tworów z użyciem języka skryptowego (React Native). Co jeszcze można tutaj ugrać i jakim asem zagrać? Zaczynajmy.\n\nJęzyk\n\n\n  Co napędza Fluttera?\n  Dart\n  W sensie to taki język programowania?\n  Tak\n  …\n\n\nMogłeś nie słyszeć o tym języku, nawet jeśli nie spędziłeś ostatnich miesięcy pod kamieniem. Nie należy do najpopularniejszych narzędzi, zwłaszcza że przed Flutterem nie miał realnego i mainstreamowego zastosowania. Według rankingu TIOBE, który śledzi popularność dostępnych języków, popularniejsze są m.in. Fortran, Scratch, czy nawet COBOL. Zaryzykuję wręcz stwierdzenie że Dart to taki trochę eksperyment developerski, który dojrzewał w piwnicy na swój moment chwały.\n\n\n\nSkładnia języka jest nowoczesna, prawdopodobnie za sprawą tego, że debiutował w 2011 roku - nie miał czasu się zestarzeć. Mógłbym napisać, że to mieszanka Javy i JavaScriptu, ale zdaję sobie sprawę jaka będzie Twoja reakcja na takie porównanie.\n\n\n\nUjmę to więc inaczej:\n\nvoid main() {\n  List&amp;lt;String&amp;gt; keywords = [&quot;Rykowski&quot;, &quot;ma&quot;];\n  keywords.add(&quot;psa&quot;);\n  keywords.forEach((keyword) =&amp;gt; print(keyword));\n  print(&quot;Lista ma ${keywords.length} elementów&quot;);\n}\n\n\nWygląda jak zwykły język programowania? Otóż to. Im lepiej poznasz język, tym bardziej docenisz jego prostotę i brak niespójności, a zarazem to że działa w sposób oczekiwany i intuicyjny. Zdaję sobie  sprawę, że trudno oceniać język po kilku linijkach kodu - obiecuję opracować dedykowany wpis samemu językowi.\n\nWarto wspomnieć, że Dart został zaprojektowany przez tą samą firmę która odpowiada za Fluttera, czyli Google. Co to oznacza, poza tym że mamy tutaj interesujący zbieg okoliczności? Z reguły języki programowania rozwijają się swoim rytmem i planem, wprowadzają zmiany i udogodnienia dla programistów, jednak każda taka zmiana jest mocno ważona i jej wprowadzenie zawsze zajmuje sporo czasu. W naszym przypadku jedna firma steruje zarówno językiem jak i biblioteką która go wykorzystuje - stąd część zmian jest mocno sterowana potrzebami frameworka. Zamknięty ekosystem wzajemnie się napędza i dostarcza wysokiej jakości narzędzie do wykorzystania przez programistów aplikacji.\n\nInterfejs użytkownika (UI)\n\nInterfejs użytkownika, czyli to co widzi użytkownik naszej aplikacji. Przyciski, przełączniki, formularze, a nawet wyświetlany tekst zawierają się w interfejsie. Flutter wprowadza sporo zamieszania i nowości w tym konkretnym temacie. Wszystko za sprawą własnego silnika renderującego Skia, który w całości odpowiada za to co w danym momencie jest wyświetlane na ekranie. Piksel po pikselu Flutter steruje widocznymi elementami, a także animacją odpowiedzialną za płynne odpowiadanie na interakcje użytkownika.\n\nCo w praktyce oznacza, że Flutter sam rysuje wszystko co jest widoczne w aplikacji? Czy inne biblioteki nie robią tego samego? Nie. Komponenty w Ionicu rysowane są przez przeglądarkę systemu - co oznacza, że będą wyglądały inaczej w zależności od tego jaka przeglądarka, a nawet wersja jest aktualnie zainstalowana na telefonie. React Native oraz Xamarin rysują natywne komponenty systemowe - z jednej strony dają nam one poczucie korzystania z aplikacji natywnej, z drugiej - trudno jest sprawić aby aplikacja wyglądała identycznie na obu platformach. Flutter sprawia, że każdy komponent będzie wyglądał identycznie na każdym urządzeniu - niezależnie od tego czy pracujemy na Androidzie, iOS-ie, a nawet przeglądarce webowej.\n\nKwestia wbudowanych komponentów graficznych które oddane są do naszej dyspozycji robi robotę. Nie będę ich tutaj opisywał, ograniczę się wyłącznie do faktu, że Flutter posiada pełne i oficjalne wsparcie dla Material Design (znowu Google). Wiesz co to znaczy, prawda? Setki prostych i stylowych elementów do wykorzystania, z czego każdy można ostylować do własnych potrzeb poprzez dedykowany obiekt styli. Wow!\n\n\n\nWydajność\n\nAplikacja podczas budowania jest kompilowana do kodu natywnego, więc nie ma się czym martwić jeśli chodzi o wydajność. Elementy renderowane są błyskawicznie, listy nie lagują podczas szybkiego scrollowania, a animacje są płynne i bez problemów osiągają mityczne 60fps. Nie zdarzyła mi się osobiście jeszcze sytuacja, w której miałbym problem natury “wydolnościowej”. Koniecznie muszę jednak zaznaczyć, że aplikacja działa w pełni płynnie dopiero gdy zbudujemy ją w trybie release - czyli takim w jakim dostanie ją użytkownik końcowy. W przypadku gdy pracujemy w trybie developerskim (hot-reloading), aplikacja działa poprawnie ale bez efektu wow - warto mieć to na uwadze, gdy rozpoczniemy swoją przygodę.\n\nEkosystem i społeczność\n\nKażda nowa technologia potrzebuje w skrócie dwóch rzeczy aby osiągnąć sukces:\n\n\n  Wysoka jakość\n  Rozbudowany ekosystem\n\n\nO ile kwestii wysokiej jakości nie ma potrzeby opisywać - słaba technologia się sama nie obroni i umrze śmiercią naturalną, to ekosystem jest rzeczą której warto się przyjrzeć. Jest to cecha nad którą Google nie ma pełnej kontroli - o ile jest w stanie dopieszczać Fluttera o nowe mechanizmy i rozwiązane błędy, to społeczność buduje się kilka kroków dalej - samodzielnie. Rozbudowany ekosystem wymaga czasu - konieczne jest zebranie odpowiedniej masy krytycznej developerów, którzy poświęcą część swojego czasu na ewangelizację technologii. Przyjmuje ona różne formy:\n\n\n  Gotowe biblioteki\n  Prezentacje i prelekcje\n  Pomoc w rozwiązywaniu problemów początkującym\n\n\nEkosystem nie jest jeszcze ustabilizowany - technologia jest młoda i nie miała jeszcze czasu tego wypracować. Istnieje co prawda wiele gotowych rozwiązań od community, jednak duża część zdążyła zostać już porzucona przez właścicieli - na próżno więc liczyć na poprawki, a lista zgłaszanych błędów wciąż rośnie. Mimo tego, że nie jest idealnie (w porównaniu choćby z React Native), to z każdym miesiącem sytuacja się polepsza. Osobiście wierzę, że rok 2019 będzie przełomowym i jako programiści będziemy mogli się cieszyć z rozbudowanego ekosystemu.\n\nDokumentacja\n\nOficjalne źródło wiedzy, które jest nieocenioną częścią samej technologii. Co z tego, że narzędzie jest świetne i najlepsze na świecie, skoro dokumentacja napisana została byle jak, a dodatkowo brakuje w niej wielu informacji i wytycznych w jaki sposób się nim posługiwać? Na nasze szczęście Google słynie z tego, że jego produkty posiadają świetną i obszerną dokumentację techniczną. Każdy niemal aspekt jest skrupulatnie i dokładnie rozpisany, a poza standardowym API reference, znajdziemy tutaj m.in:\n\n\n  Najlepsze praktyki dotyczące testowania i debugowania aplikacji\n  Ścieżki wdrożeniowe dla programistów innych technologii (w tym React Native, czy Web)\n  Wysokopoziomowe poradniki dotyczące layoutów, interakcji, czy sterowania animacjami\n  W jaki sposób zbudować aplikację produkcyjną wraz z Continuous Deployment\n\n\nJestem mocno zaskoczony - pozytywnie - że tak młoda technologia jak Flutter posiada tak rozbudowaną i obszerną dokumentację na każdy istotny temat. Jeśli chcesz dogłębnie poznać dowolne zagadnienie z zakresu frameworka, znajdziesz je właśnie w oficjalnej dokumentacji, która dostępna jest pod adresem https://flutter.dev/docs\n\nCzy warto?\n\nPrzy nowych technologiach pojawia się zawsze to samo pytanie - czy warto się nią zainteresować i czy w długiej perspektywie czas spędzony na nauce się zwróci (mówię rzecz jasna o $$$)? Nie mam jednoznacznej odpowiedzi na to pytanie, nie wezmę odpowiedzialności za to jak inwestujesz swój czas. Wszystko jednak wskazuje na to, że Flutter zostanie na rynku długo i warto wskoczyć już teraz do jego wagonika. Early adopters would be rewarded.\n"
} 
  
  ,
  
  {
  
  "title"    : "Ninja",
  "category" : "",
  "tags"     : " Lorem",
  "url"      : "/portfolio/ninja",
  "date"     : "April 8, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Creative",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/portfolio/safe",
  "date"     : "August 16, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n"
  
} ,
  
  {
  
  "title"    : "Circus",
  "category" : "",
  "tags"     : " Ipsum",
  "url"      : "/portfolio/circus",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tower of Hanoi",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/hanoi",
  "date"     : "September 1, 2014",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Tic tac toe",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/tictactoe",
  "date"     : "September 1, 2014",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Cake",
  "category" : "",
  "tags"     : " Lorem, Ipsum, Portfolio",
  "url"      : "/portfolio/cake",
  "date"     : "September 27, 2015",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n"
  
} ,
  
  {
  
  "title"    : "Jekyll",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/jekyllblog",
  "date"     : "May 26, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} ,
  
  {
  
  "title"    : "Lorem Ipsum",
  "category" : "",
  "tags"     : " ",
  "url"      : "/portfolio/submarine",
  "date"     : "September 3, 2017",
  "excerpt"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia...",
  "content"  : "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\nUse this area of the page to describe your project. The icon above is part of a free icon set by Flat Icons. On their website, you can download their free set with 16 icons, or you can purchase the entire set with 146 icons for only $12!\n\n"
  
} ,
  
  {
  
  "title"    : "Github",
  "category" : "",
  "tags"     : " Lorem, Portfolio",
  "url"      : "/portfolio/gitlecture",
  "date"     : "October 20, 2017",
  "excerpt"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem qu...",
  "content"  : "\n\nSed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt. Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem. Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?\n\n"
  
} 
  
]
